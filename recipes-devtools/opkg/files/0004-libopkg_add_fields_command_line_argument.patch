From: Dan Mondrik <dan.m...@ni.com>
Subject: [PATCH] libopkg: add --fields command line argument
Date: Mon, 26 Nov 2018 17:35:34 -0600

The commands 'info' and 'status' now support the --fields command line
argument with a comma delimited list of fields the user wants displayed.
This allows client parsing of the results to be simpler and faster.

Upstream-Status: Accepted [https://groups.google.com/forum/#!topic/opkg-devel/prR6-5HztXU]
Signed-off-by: Dan Mondrik <dan.m...@ni.com>
---
 libopkg/opkg_cmd.c           |   4 +-
 libopkg/opkg_conf.h          |   1 +
 libopkg/pkg.c                | 111 +++++++++++++++++++----------------
 libopkg/pkg.h                |   2 +-
 src/opkg.c                   |   7 +++
 tests/Makefile               |   2 +
 tests/core/41_info_fields.py |  50 ++++++++++++++++
 tests/opkgcl.py              |   6 ++
 8 files changed, 128 insertions(+), 55 deletions(-)
 create mode 100644 tests/core/41_info_fields.py

diff --git a/libopkg/opkg_cmd.c b/libopkg/opkg_cmd.c
index 774e4d9..fd27062 100644
--- a/libopkg/opkg_cmd.c
+++ b/libopkg/opkg_cmd.c
@@ -638,7 +638,7 @@ static int opkg_info_status_cmd(int argc, char **argv, int installed_only)
             continue;
         }
 
-        pkg_formatted_info(stdout, pkg);
+        pkg_formatted_info(stdout, pkg, opkg_config->fields_filter);
 
         if (opkg_config->verbosity >= INFO) {
             conffile_list_elt_t *iter;
@@ -661,7 +661,7 @@ static int opkg_info_status_cmd(int argc, char **argv, int installed_only)
         if (err)
             return err;
         hash_insert_pkg(pkg, 0);
-        pkg_formatted_info(stdout, pkg);
+        pkg_formatted_info(stdout, pkg, opkg_config->fields_filter);
     }
 
     return 0;
diff --git a/libopkg/opkg_conf.h b/libopkg/opkg_conf.h
index 0f65cab..01b8dfc 100644
--- a/libopkg/opkg_conf.h
+++ b/libopkg/opkg_conf.h
@@ -75,6 +75,7 @@ typedef struct opkg_conf {
     char *lock_file;
     char *info_dir;
     char *status_file;
+    char *fields_filter; /* specific fields the user requests */
 
     unsigned int pfm;       /* package field mask */
 
diff --git a/libopkg/pkg.c b/libopkg/pkg.c
index 125520b..eb4da0f 100644
--- a/libopkg/pkg.c
+++ b/libopkg/pkg.c
@@ -546,13 +546,21 @@ static const char *pkg_state_status_to_str(pkg_state_status_t ss)
     return "<STATE_STATUS_UNKNOWN>";
 }
 
-static void pkg_formatted_field(FILE * fp, pkg_t * pkg, const char *field)
+static int should_include_field(const char *field, const char *fields_filter)
+{
+   return field && (!fields_filter || strstr(fields_filter, field));
+}
+
+static void pkg_formatted_field(FILE * fp, pkg_t * pkg, const char *field, const char *fields_filter)
 {
     unsigned int i, j;
     char *str;
     unsigned int depends_count = pkg->pre_depends_count + pkg->depends_count
         + pkg->recommends_count + pkg->suggests_count;
 
+    if (!should_include_field(field, fields_filter)) {
+       return;
+    }
     if (strlen(field) < PKG_MINIMUM_FIELD_NAME_LEN) {
         goto UNKNOWN_FMT_FIELD;
     }
@@ -807,7 +815,7 @@ static void pkg_formatted_field(FILE * fp, pkg_t * pkg, const char *field)
     opkg_msg(ERROR, "Internal error: field=%s\n", field);
 }
 
-static void pkg_formatted_userfields(FILE *fp, pkg_t *pkg)
+static void pkg_formatted_userfields(FILE *fp, pkg_t *pkg, const char *fields_filter)
 {
     nv_pair_list_elt_t *iter;
 
@@ -818,9 +826,8 @@ static void pkg_formatted_userfields(FILE *fp, pkg_t *pkg)
                 iter = nv_pair_list_next(&pkg->userfields, iter)) {
         nv_pair_t *uf = (nv_pair_t *)iter->data;
 
-        if (uf->name && uf->value) {
-            fprintf(fp, "%s: %s\n", ((nv_pair_t *)iter->data)->name,
-                    ((nv_pair_t *)iter->data)->value);
+        if (should_include_field(uf->name, fields_filter) && uf->value) {
+            fprintf(fp, "%s: %s\n", uf->name, uf->value);
         }
     }
 }
@@ -839,32 +846,32 @@ pkg_state_status_t pkg_state_status_from_str(const char *str)
     return SS_NOT_INSTALLED;
 }
 
-void pkg_formatted_info(FILE * fp, pkg_t * pkg)
+void pkg_formatted_info(FILE * fp, pkg_t * pkg, const char *fields_filter)
 {
-    pkg_formatted_field(fp, pkg, "Package");
-    pkg_formatted_field(fp, pkg, "Version");
-    pkg_formatted_field(fp, pkg, "Depends");
-    pkg_formatted_field(fp, pkg, "Recommends");
-    pkg_formatted_field(fp, pkg, "Suggests");
-    pkg_formatted_field(fp, pkg, "Provides");
-    pkg_formatted_field(fp, pkg, "Replaces");
-    pkg_formatted_field(fp, pkg, "Conflicts");
-    pkg_formatted_field(fp, pkg, "Status");
-    pkg_formatted_field(fp, pkg, "Section");
-    pkg_formatted_field(fp, pkg, "Essential");
-    pkg_formatted_field(fp, pkg, "Architecture");
-    pkg_formatted_field(fp, pkg, "Maintainer");
-    pkg_formatted_field(fp, pkg, "MD5sum");
-    pkg_formatted_field(fp, pkg, "Size");
-    pkg_formatted_field(fp, pkg, "Filename");
-    pkg_formatted_field(fp, pkg, "Conffiles");
-    pkg_formatted_field(fp, pkg, "Source");
-    pkg_formatted_field(fp, pkg, "Description");
-    pkg_formatted_field(fp, pkg, "Installed-Size");
-    pkg_formatted_field(fp, pkg, "Installed-Time");
-    pkg_formatted_field(fp, pkg, "Tags");
+    pkg_formatted_field(fp, pkg, "Package", NULL);
+    pkg_formatted_field(fp, pkg, "Version", fields_filter);
+    pkg_formatted_field(fp, pkg, "Depends", fields_filter);
+    pkg_formatted_field(fp, pkg, "Recommends", fields_filter);
+    pkg_formatted_field(fp, pkg, "Suggests", fields_filter);
+    pkg_formatted_field(fp, pkg, "Provides", fields_filter);
+    pkg_formatted_field(fp, pkg, "Replaces", fields_filter);
+    pkg_formatted_field(fp, pkg, "Conflicts", fields_filter);
+    pkg_formatted_field(fp, pkg, "Status", fields_filter);
+    pkg_formatted_field(fp, pkg, "Section", fields_filter);
+    pkg_formatted_field(fp, pkg, "Essential", fields_filter);
+    pkg_formatted_field(fp, pkg, "Architecture", fields_filter);
+    pkg_formatted_field(fp, pkg, "Maintainer", fields_filter);
+    pkg_formatted_field(fp, pkg, "MD5sum", fields_filter);
+    pkg_formatted_field(fp, pkg, "Size", fields_filter);
+    pkg_formatted_field(fp, pkg, "Filename", fields_filter);
+    pkg_formatted_field(fp, pkg, "Conffiles", fields_filter);
+    pkg_formatted_field(fp, pkg, "Source", fields_filter);
+    pkg_formatted_field(fp, pkg, "Description", fields_filter);
+    pkg_formatted_field(fp, pkg, "Installed-Size", fields_filter);
+    pkg_formatted_field(fp, pkg, "Installed-Time", fields_filter);
+    pkg_formatted_field(fp, pkg, "Tags", fields_filter);
     if (opkg_config->verbose_status_file) {
-        pkg_formatted_userfields(fp, pkg);
+        pkg_formatted_userfields(fp, pkg, fields_filter);
     }
     fputs("\n", fp);
 }
@@ -875,36 +882,36 @@ void pkg_print_status(pkg_t * pkg, FILE * file)
         return;
     }
 
-    pkg_formatted_field(file, pkg, "Package");
-    pkg_formatted_field(file, pkg, "Version");
-    pkg_formatted_field(file, pkg, "Depends");
-    pkg_formatted_field(file, pkg, "Recommends");
-    pkg_formatted_field(file, pkg, "Suggests");
-    pkg_formatted_field(file, pkg, "Provides");
-    pkg_formatted_field(file, pkg, "Replaces");
-    pkg_formatted_field(file, pkg, "Conflicts");
-    pkg_formatted_field(file, pkg, "Status");
+    pkg_formatted_field(file, pkg, "Package", NULL);
+    pkg_formatted_field(file, pkg, "Version", NULL);
+    pkg_formatted_field(file, pkg, "Depends", NULL);
+    pkg_formatted_field(file, pkg, "Recommends", NULL);
+    pkg_formatted_field(file, pkg, "Suggests", NULL);
+    pkg_formatted_field(file, pkg, "Provides", NULL);
+    pkg_formatted_field(file, pkg, "Replaces", NULL);
+    pkg_formatted_field(file, pkg, "Conflicts", NULL);
+    pkg_formatted_field(file, pkg, "Status", NULL);
     if (opkg_config->verbose_status_file) {
-        pkg_formatted_field(file, pkg, "Section");
+        pkg_formatted_field(file, pkg, "Section", NULL);
     }
-    pkg_formatted_field(file, pkg, "Essential");
-    pkg_formatted_field(file, pkg, "Architecture");
+    pkg_formatted_field(file, pkg, "Essential", NULL);
+    pkg_formatted_field(file, pkg, "Architecture", NULL);
     if (opkg_config->verbose_status_file) {
-        pkg_formatted_field(file, pkg, "Maintainer");
-        pkg_formatted_field(file, pkg, "MD5sum");
-        pkg_formatted_field(file, pkg, "Size");
-        pkg_formatted_field(file, pkg, "Filename");
+        pkg_formatted_field(file, pkg, "Maintainer", NULL);
+        pkg_formatted_field(file, pkg, "MD5sum", NULL);
+        pkg_formatted_field(file, pkg, "Size", NULL);
+        pkg_formatted_field(file, pkg, "Filename", NULL);
     }
-    pkg_formatted_field(file, pkg, "Conffiles");
+    pkg_formatted_field(file, pkg, "Conffiles", NULL);
     if (opkg_config->verbose_status_file) {
-        pkg_formatted_field(file, pkg, "Source");
-        pkg_formatted_field(file, pkg, "Description");
+        pkg_formatted_field(file, pkg, "Source", NULL);
+        pkg_formatted_field(file, pkg, "Description", NULL);
     }
-    pkg_formatted_field(file, pkg, "Installed-Size");
-    pkg_formatted_field(file, pkg, "Installed-Time");
-    pkg_formatted_field(file, pkg, "Auto-Installed");
+    pkg_formatted_field(file, pkg, "Installed-Size", NULL);
+    pkg_formatted_field(file, pkg, "Installed-Time", NULL);
+    pkg_formatted_field(file, pkg, "Auto-Installed", NULL);
     if (opkg_config->verbose_status_file) {
-        pkg_formatted_userfields(file, pkg);
+        pkg_formatted_userfields(file, pkg, NULL);
     }
     fputs("\n", file);
 }
diff --git a/libopkg/pkg.h b/libopkg/pkg.h
index 6ff9cfa..d269528 100644
--- a/libopkg/pkg.h
+++ b/libopkg/pkg.h
@@ -202,7 +202,7 @@ int pkg_compare_versions_no_reinstall(const pkg_t * pkg, const pkg_t * ref_pkg);
 int pkg_name_version_and_architecture_compare(const void *a, const void *b);
 int abstract_pkg_name_compare(const void *a, const void *b);
 
-void pkg_formatted_info(FILE * fp, pkg_t * pkg);
+void pkg_formatted_info(FILE * fp, pkg_t * pkg, const char *fields_filter);
 
 void set_flags_from_control(pkg_t * pkg);
 
diff --git a/src/opkg.c b/src/opkg.c
index 3495d18..3bcdc1c 100644
--- a/src/opkg.c
+++ b/src/opkg.c
@@ -60,6 +60,7 @@ enum {
     ARGS_OPT_NO_INSTALL_RECOMMENDS,
     ARGS_OPT_CACHE_DIR,
     ARGS_OPT_HOST_CACHE_DIR,
+    ARGS_OPT_FIELDS_FILTER,
 };
 
 static struct option long_options[] = {
@@ -118,6 +119,7 @@ static struct option long_options[] = {
     {"cache-dir", 1, 0, ARGS_OPT_CACHE_DIR},
     {"host-cache-dir", 0, 0, ARGS_OPT_HOST_CACHE_DIR},
     {"volatile-cache", 0, 0, ARGS_OPT_VOLATILE_CACHE},
+    {"fields", 1, 0, ARGS_OPT_FIELDS_FILTER},
     {"verbosity", 2, 0, 'V'},
     {"version", 0, 0, 'v'},
     {0, 0, 0, 0}
@@ -251,6 +253,9 @@ static int args_parse(int argc, char *argv[])
         case ARGS_OPT_NO_INSTALL_RECOMMENDS:
             opkg_config->no_install_recommends = 1;
             break;
+        case ARGS_OPT_FIELDS_FILTER:
+            opkg_config->fields_filter = xstrdup(optarg);
+            break;
         case ARGS_OPT_COMBINE:
             opkg_config->combine = 1;
             break;
@@ -336,6 +341,8 @@ static void usage()
     printf("\t--combine                       Combine upgrade and install operations, this\n");
     printf("\t                                may be needed to resolve dependency issues.\n");
     printf("\t                                Only available for the internal solver backend.\n");
+    printf("\t--fields <Field1,Field2>        Limit display information to the specified fields\n");
+    printf("\t                                plus the package name. Valid for info and status.\n");
 
     printf("\nForce Options:\n");
     printf("\t--force-depends                 Install/remove despite failed dependencies\n");
diff --git a/tests/Makefile b/tests/Makefile
index 92db8c7..3d69d18 100644
--- a/tests/Makefile
+++ b/tests/Makefile
@@ -40,6 +40,7 @@ REGRESSION_TESTS := core/01_install.py \
 		    core/38_install_constrained_version.py \
 		    core/39_distupgrade.py \
 		    core/40_arch.py \
+		    core/41_info_fields.py \
 		    regress/issue26.py \
 		    regress/issue31.py \
 		    regress/issue32.py \
@@ -89,6 +90,7 @@ REGRESSION_TESTS := core/01_install.py \
 		    misc/filehash.py \
 		    misc/update_loses_autoinstalled_flag.py \
 		    misc/version_comparisons.py
+
 RUN_TESTS := $(REGRESSION_TESTS:%.py=run-%.py)
 
 regress: $(RUN_TESTS)
diff --git a/tests/core/41_info_fields.py b/tests/core/41_info_fields.py
new file mode 100644
index 0000000..4b527b9
--- /dev/null
+++ b/tests/core/41_info_fields.py
@@ -0,0 +1,50 @@
+#! /usr/bin/env python3
+#
+# Create package 'a(1.0)' with 2 other fields.
+# Check that info command reports all fields without a filter.
+# Check that info command reports specified fields only with a filter.
+#
+
+import os
+import opk, cfg, opkgcl
+
+opk.regress_init()
+
+o = opk.OpkGroup()
+o.add(Package="a", Version="1.0", Description="d", Section="s")
+o.write_opk()
+o.write_list()
+
+opkgcl.update()
+
+info = opkgcl.info("a")
+if "Package" not in info:
+        opk.fail(info)
+if "Version" not in info:
+        opk.fail("Package 'a' information should contain 'Version' field")
+if "Description" not in info:
+        opk.fail("Package 'a' information should contain 'Description' field")
+if "Section" not in info:
+        opk.fail("Package 'a' information should contain 'Section' field")
+if "Essential" in info:
+        opk.fail("Package 'a' information should not contain 'Essential' field because it is not in the package")
+
+info = opkgcl.info("a", "Version,Description,SomethingElse")
+if "Package" not in info:
+        opk.fail("Package 'a' information should contain 'Package' field even if it's not in the filter")
+if "Version" not in info:
+        opk.fail("Package 'a' information should contain 'Version' field because it is in the filter")
+if "Description" not in info:
+        opk.fail("Package 'a' information should contain 'Description' field because it is in the filter")
+if "Section" in info:
+        opk.fail("Package 'a' information should not contain 'Section' field because it is not in the filter")
+
+info = opkgcl.info("a", "SomethingElse")
+if "Package" not in info:
+        opk.fail("Package 'a' information should contain 'Package' field even if it's not in the filter")
+if "Version" in info:
+        opk.fail("Package 'a' information should not contain 'Version' field because it is not in the filter")
+if "Description" in info:
+        opk.fail("Package 'a' information should not contain 'Description' field because it is not in the filter")
+if "Section" in info:
+        opk.fail("Package 'a' information should not contain 'Section' field because it is not in the filter")
diff --git a/tests/opkgcl.py b/tests/opkgcl.py
index 2f011d0..d199d71 100755
--- a/tests/opkgcl.py
+++ b/tests/opkgcl.py
@@ -27,6 +27,12 @@ def upgrade(params=None, flags=""):
 	else:
 		return opkgcl("--force-postinstall upgrade")[0]
 
+def info(pkg_name, params=None):
+	if params:
+		return opkgcl("--fields {} info {}".format(params, pkg_name))[1]
+	else:
+		return opkgcl("info {}".format(pkg_name))[1]
+
 def distupgrade(params=None, flags=""):
 	if params:
 		return opkgcl("{} --force-postinstall dist-upgrade {}".format(flags, params))[0]
-- 
2.19.1.windows.1

