From ec78842fee12f33a0cf1bc7d99bb46823e2b83bf Mon Sep 17 00:00:00 2001
From: Haris Okanovic <haris.okanovic@ni.com>
Date: Fri, 7 Aug 2015 12:48:58 -0500
Subject: [PATCH] semodule: Stack size limit check for NILRT

Verify the stack size limit is sufficient to run semodule in order to
avoid unpleasant overflow errors. Immediately exit with error message
otherwise.

Signed-off-by: Haris Okanovic <haris.okanovic@ni.com>
---
 semodule/semodule.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/semodule/semodule.c b/semodule/semodule.c
index 6aa11818276c69347a5376dbddb6ada0945da400..5a4f7870b06f0ee87a86f1b34eb8240e1f77f922 100644
--- a/semodule/semodule.c
+++ b/semodule/semodule.c
@@ -10,20 +10,21 @@
 
 #include <fcntl.h>
 #include <getopt.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <string.h>
 #include <unistd.h>
 #include <sys/mman.h>
+#include <sys/resource.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <libgen.h>
 
 #include <semanage/modules.h>
 
 enum client_modes { NO_MODE, INSTALL_M, UPGRADE_M, BASE_M, ENABLE_M, DISABLE_M, REMOVE_M,
 	LIST_M, RELOAD
 };
 /* list of modes in which one ought to commit afterwards */
@@ -80,20 +81,35 @@ static void set_store(char *storename)
 		goto bad;
 	}
 
 	return;
 
       bad:
 	cleanup();
 	exit(1);
 }
 
+/* Verify there's enough stack space to run this program */
+static void check_stack_size(void)
+{
+    struct rlimit rl;
+    if(getrlimit(RLIMIT_STACK, &rl) != 0) {
+        fprintf(stderr, "Failed to get stack size limit.\n");
+        exit(1);
+    }
+    if(rl.rlim_cur < 1024*1024) {
+        fprintf(stderr, "Stack is too small.\n"
+            "Run `ulimit -s 1024` to increase stack size limit to 1 MB before running this program.\n");
+        exit(1);
+    }
+}
+
 /* Establish signal handlers for the process. */
 static void create_signal_handlers(void)
 {
 	if (signal(SIGINT, handle_signal) == SIG_ERR ||
 	    signal(SIGQUIT, handle_signal) == SIG_ERR ||
 	    signal(SIGTERM, handle_signal) == SIG_ERR) {
 		fprintf(stderr, "Could not set up signal handler.\n");
 		exit(255);
 	}
 }
@@ -279,20 +295,21 @@ static void parse_command_line(int argc, char **argv)
 			set_mode(mode, argv[optind++]);
 	}
 }
 
 int main(int argc, char *argv[])
 {
 	int i, commit = 0;
 	int result;
 	int status = EXIT_FAILURE;
 	char *genhomedirconargv[] = { "genhomedircon", "-B", "-n" };
+	check_stack_size();
 	create_signal_handlers();
 	if (strcmp(basename(argv[0]), "genhomedircon") == 0) {
 		argc = 3;
 		argv=genhomedirconargv;
 	}
 	parse_command_line(argc, argv);
 
 	if (build)
 		commit = 1;
 
-- 
2.4.5

