#!/bin/bash
#this file contains the functions needed by the provisioning tool

ANSWER_FILE_DISK_MOUNTPOINT=/var/volatile/answerFileDisk
USB_MOUNTPOINT=/var/volatile/usbrtdeploy
NILRT_MOUNTPOINT=/var/volatile/nilrt
NIRESTORE_MOUNTPOINT=/var/volatile/nirestore
NICONFIG_MOUNTPOINT=/var/volatile/niconfig
GRUB_MOUNTPOINT=/var/volatile/nigrub
BOOTFS_MOUNTPOINT=/var/volatile/nibootfs
ROOTFS_MOUNTPOINT=/var/volatile/nirootfs
TEMP_MOUNTPOINT=/var/volatile/temp_dir
TARGET_DISK=""
TARGET_DISK_SEARCH_TIME=30
NIGRUB_LABEL=nigrub
NIRESTORE_LABEL=nirestore
NILRT_LABEL=nilrt
OLDER_NILRT_NIBOOTFS_LABEL=nibootfs
LOG_LEVEL=7
RED='\e[0;31m'
NC='\e[0m'
YELLOW='\e[1;33m'
GREEN='\e[0;32m'
ASK_BEFORE_REBOOT=0
ARCH=`uname -m`
VERBOSE_ARGS=${VERBOSE_ARGS:-"-q"}
MKFS_ARGS=${MKFS_ARGS:-"$VERBOSE_ARGS -F"}
verbose_mode=${verbose_mode:-0}

if [ $verbose_mode -eq 0 ]; then
    do_silent() { "$@" &>/dev/null; };
else
    do_silent() { "$@"; }
fi

get_image_info()
{
    TOKEN=$1

    grep -Po "(?<=${TOKEN}=).*" /payload/imageinfo
}

ask_for_continue()
{
    type=${1:-"Recovery"}
    variable=${2:-"PROVISION_REPARTITION_TARGET"}

    BUILD_IDENTIFIER=$(get_image_info BUILD_IDENTIFIER)

    printf "\nNI Linux Real-Time $type $BUILD_IDENTIFIER. \n\n"
    printf "The boot style is ${RED}$(echo $BOOT_STYLE | tr a-z A-Z)${NC}\n\n"
    printf "Continuing will partition the disk, format, and install safemode to the target.\n\n"

    prompt_user "Do you want to continue? [y/N]" "^(y|n)$" "n" $variable
}

provision_sucessfull()
{
    do_silent mount
    echo -e ${GREEN}"PROVISIONING SUCCESSFUL!"${NC} 1>&3 2>&4
}

umount_partition()
{
    if [ ! -z "`mount | grep $1`" ]; then
        umount $1 &>/dev/null
    fi
}

umount_partitions()
{
    for PART in `ls -1 ${TARGET_DISK}* | tail -n +2`
    do
        umount_partition $PART
    done
}

cleanup_and_exit()
{
    echo $LOG_LEVEL > /proc/sys/kernel/printk
    trap - ERR

    sync

    if [ "$ARCH" = "armv7l" ]; then
        #set the bootmode to default
        echo -n 00 >  /sys/bus/i2c/devices/0-0040/scratch_hardreset
    fi

    if (( $1 == 0  && $ASK_BEFORE_REBOOT == 1 )); then
        echo "Unmounting all file systems:"
        do_silent umount -a -r -t devtmpfs,vfat,ext4 # sysfs, procfs and rootfs aren't unmounted
        echo u > /proc/sysrq-trigger
        sync

        if [[ "${PROVISION_REBOOT_METHOD}" == "reboot" ]]; then
            echo "Rebooting"
            reboot -f
            sleep 1
            echo b > /proc/sysrq-trigger
            sleep 1
        elif [[ "${PROVISION_REBOOT_METHOD}" == "poweroff" ]]; then
            echo "Powering off"
            poweroff -f
            sleep 1
            echo o > /proc/sysrq-trigger
            sleep 1
        else
            echo "Dropping to shell"
        fi
    fi

    exit $1
}

die()
{
    echo -e "${RED}\n***Error: $1\nPROVISIONING FAILED!${NC}"
    cleanup_and_exit 1
}

if [ -e /disk_config ]; then
    source /disk_config
else
    die "disk_config not found!"
fi

if [ "$ARCH" = "armv7l" ]; then

    restore_minimal_image()
    {
        echo "Formatting ubi1:rootfs..."
        format_ubi_volume root 0 rootfs
        echo "Done"
        mkdir -p $NILRT_MOUNTPOINT
        mkdir -p $NIRESTORE_MOUNTPOINT
        MOUNT_ERROR=`mount -t ubifs ubi1:rootfs $NILRT_MOUNTPOINT` || die "$MOUNT_ERROR"
        echo "Deploying minimal image..."
        # NOTE: `--numeric-owner` option: always use numbers for user/group names (ignore symbolic names)
        TAR_ERROR="`tar -x -j --numeric-owner -f /payload/factory-image.tar.bz2 -C $NILRT_MOUNTPOINT 2>&1`" || die "$TAR_ERROR"
        cp /payload/*.scr $NILRT_MOUNTPOINT/boot/
        ln -sf $NILRT_MOUNTPOINT/boot/uImage-* /boot/uImage
        MOUNT_ERROR=`mount -t ubifs ubi0:bootfs $NIRESTORE_MOUNTPOINT` || die "$MOUNT_ERROR"
        cp $NIRESTORE_MOUNTPOINT/.restore/ni-*.dtb $NILRT_MOUNTPOINT/boot/
        cp /payload/nxg_redirect_runmode_boot.itb $NIRESTORE_MOUNTPOINT/linux_runmode.itb
        sync
        do_silent umount $NILRT_MOUNTPOINT || die "Failed to umount $NILRT_MOUNTPOINT"
        do_silent umount $NIRESTORE_MOUNTPOINT || die "Failed to umount $NIRESTORE_MOUNTPOINT"
        echo "Minimal image deployed."
        ASK_BEFORE_REBOOT=1
        provision_sucessfull
    }

    provision_target()
    {
        mkdir -p $NILRT_MOUNTPOINT
        mkdir -p $NIRESTORE_MOUNTPOINT
        mkdir -p $NICONFIG_MOUNTPOINT
        mkdir -p $TEMP_MOUNTPOINT

        MOUNT_ERROR=`mount -t ubifs ubi1:rootfs $NILRT_MOUNTPOINT` || die "$MOUNT_ERROR"
        MOUNT_ERROR=`mount -t ubifs ubi0:bootfs $NIRESTORE_MOUNTPOINT` || die "$MOUNT_ERROR"
        MOUNT_ERROR=`mount -t ubifs ubi0:config $NICONFIG_MOUNTPOINT` || die "$MOUNT_ERROR"
        DEVICE_CODE=`fw_printenv -n DeviceCode`

        if [[ $restore == "migrate" ]]; then
            #replace the linux_safemode.itb with the fake one
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.safe/nxg_redirect_safemode_boot.itb $NIRESTORE_MOUNTPOINT/.safe/linux_safemode.itb
            #copy all the necessary files for restore-mode
            mkdir -p $NIRESTORE_MOUNTPOINT/.restore
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.restore/dtbs/ni-$DEVICE_CODE.dtb $NIRESTORE_MOUNTPOINT/.restore/ || die "ni-$DEVICE_CODE.dtb file not found!"
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.restore/uImage $NIRESTORE_MOUNTPOINT/.restore/ || die "Kernel not found!"
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.restore/ramdisk $NIRESTORE_MOUNTPOINT/.restore/ || die "Ramdisk not found!"
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.restore/restore.scr $NIRESTORE_MOUNTPOINT/.restore/ || die "Restore script not found!"

            #clear config contents which are unused in newer versions of NILRT
            rm -rf $NICONFIG_MOUNTPOINT/*

            sync
            umount $NILRT_MOUNTPOINT || die "Failed to umount $NILRT_MOUNTPOINT"
            umount $NIRESTORE_MOUNTPOINT || die "Failed to umount $NIRESTORE_MOUNTPOINT"
            umount $NICONFIG_MOUNTPOINT || die "Failed to umount $NICONFIG_MOUNTPOINT"

            restore_minimal_image

        elif [[ $restore == "backward-migrate" ]]; then

            printf "Removing the already installed nilrt... "
            rm -rf $NIRESTORE_MOUNTPOINT/.safe
            rm -rf $NIRESTORE_MOUNTPOINT/.restore
            rm -rf $NIRESTORE_MOUNTPOINT/.defbit
            rm -f $NIRESTORE_MOUNTPOINT/linux_runmode.itb
            echo "done."

            printf "Deploying older NILRT version safemode on target... "
            mkdir -p $NIRESTORE_MOUNTPOINT/.safe
            mkdir -p $NIRESTORE_MOUNTPOINT/.defbit

            NON_HEX_DEV_CODE=$(echo $DEVICE_CODE | awk '{print substr($0,3)}')
            DEVCFG_PATH=$NILRT_MOUNTPOINT/$NON_HEX_DEV_CODE

            mkdir -p $DEVCFG_PATH/cfg-contents
            mkdir -p $DEVCFG_PATH/cfg-contents/bitfiles-contents

            # NOTE: `--no-same-owner` option: extract files as current user (default for ordinary users)
            tar -x --no-same-owner -f $DEVCFG_PATH/*.cfg -C $DEVCFG_PATH/cfg-contents/ || die "Could not extract cfg from $NILRT_MOUNTPOINT/$NON_HEX_DEV_CODE"
            tar -x --no-same-owner -f $DEVCFG_PATH/cfg-contents/bitfiles.tgz -C $DEVCFG_PATH/cfg-contents/bitfiles-contents/ || die "Could not extract bitfiles.tgz"

            cp $DEVCFG_PATH/cfg-contents/linux_safemode.itb $NIRESTORE_MOUNTPOINT/.safe/linux_safemode.itb || die "linux_safemode.itb not found"

            if [ -d "$DEVCFG_PATH/cfg-contents/bitfiles-contents/$DEVICE_CODE" ]; then
                cp $DEVCFG_PATH/cfg-contents/bitfiles-contents/$DEVICE_CODE/default.bit.* $NIRESTORE_MOUNTPOINT/.defbit/
            else
                cp $DEVCFG_PATH/cfg-contents/bitfiles-contents/default.bit.* $NIRESTORE_MOUNTPOINT/.defbit/
            fi
            echo "done."

            sync
            do_silent umount $NILRT_MOUNTPOINT || die "Failed to umount $NILRT_MOUNTPOINT"
            do_silent umount $NIRESTORE_MOUNTPOINT || die "Failed to umount $NIRESTORE_MOUNTPOINT"
            do_silent umount $NICONFIG_MOUNTPOINT || die "Failed to umount $NICONFIG_MOUNTPOINT"

            printf "Formatting ubi1:rootfs... "
            format_ubi_volume root 0 rootfs
            echo "done."

            ASK_BEFORE_REBOOT=1
            provision_sucessfull
        fi
    }

elif [ "$ARCH" = "x86_64" ]; then

    show_help()
    {
        >&3 echo -e "\nUsage: $0 [-hav] [-t DEVICE]\n"
        >&3 echo -e "Options\n"
        >&3 echo "   -h : Show help."
        >&3 echo "   -a : Ask at every error if continue. Default is N, so at the first error abort."
        >&3 echo "   -v : Verbose mode."
        >&3 echo "   -t DEVICE : DEVICE is the device name for the disk to update. (e.g /dev/sda)"
        >&3 echo "               If DEVICE is not specificed, the first non-removable block device"
        >&3 echo "               that is not the recovery tool is used."
        >&3 echo "   -r y|n : Force use of initramfs style boot for runmode (compatible 2018 and later)."
        >&3 echo "            Also enables bootflag.d directory for bootmode selection. Determined"
        >&3 echo "            automatically when unspecified."
        >&3 echo "   -c y|n : Initial value of the console out enable flag."
        >&3 echo "   -b SECONDS : Initial value of bootdelay -- how long (seconds) to show boot menu."
    }

    # For a given block device (represented by sysfs path $1 and block device path
    # $2), return zero if suitable for provisioning.
    check_block_device () {
        local path=$1 block=$2

        if ! (( $? == 0 )); then
            (( verbose_mode )) && echo "SKIPPED $path_abbrev: udevadm failed" >&2
            return 1
        fi

        # Skip zero-size devices. This catches unattached loop*.
        if ! (( $(<$path/size) > 0 )); then
            (( verbose_mode )) && echo "SKIPPED $path_abbrev: size==0" >&2
            return 1
        fi

        # Skip removable devices; we're only interested in internal disks. This
        # catches USBs and CDs.
        if ! (( $(<$path/removable) == 0 )); then
            (( verbose_mode )) && echo "SKIPPED $path_abbrev: removable!=0" >&2
            return 1
        fi

        # Skip read-only devices. This catches mmcblk*boot*, but *not*
        # CDs, unless a read-only CD is present in the drive.
        if ! (( $(<$path/ro) == 0 )); then
            (( verbose_mode )) && echo "SKIPPED $path_abbrev: ro!=0" >&2
            return 1
        fi

        # Skip purely virtual devices. This catches zram* and loop* (again).
        if ! [[ -d $path/device ]]; then
            (( verbose_mode )) && echo "SKIPPED $path_abbrev: no device/" >&2
            return 1
        fi

        # $path/device/block must exist. This catches mmcblk*boot* (again).
        if ! ( [[ -d $path/device/block/ ]] || [[ -d $path/device/${path##*/} ]] ); then
            (( verbose_mode )) && echo "SKIPPED $path_abbrev: no device/block/" >&2
            return 1
        fi

        # Skip the recovery partition itself. Scan all partitions that might be present
        # at/underneath the given block device.
        for p in ${block}*; do
            local label=`lsblk $p -n -o LABEL 2>/dev/null`
            if [[ "$label" == "NIRECOVERY" ]]; then
                (( verbose_mode )) && echo "SKIPPED $path_abbrev: contains NIRECOVERY" >&2
                return 1
            fi
        done

        return 0
    }

    find_target_block_device()
    {
        local selected_block=""

        for path in /sys/block/*; do
            path_abbrev=${path##/sys/block/}
            local block=$(udevadm info -r --query=name --path=$path)
            check_block_device $path $block || continue

            # Looks good. Select the first device we see.
            if [[ $selected_block ]]; then
                (( verbose_mode )) && echo "SKIPPED block device $path_abbrev" >&2
            else
                selected_block=$block
                (( verbose_mode )) && echo "SELECTED block device $path_abbrev" >&2
            fi
        done

        if [[ $selected_block ]]; then
            echo "$selected_block"
        else
            return 1
        fi
    }

    restore_minimal_image()
    {
        local nilrt_path="$1" uuid="$2" nilrt_label="$3"

        NILRT_MOUNTPOINT=/var/volatile/nilrt
        mkdir -p $NILRT_MOUNTPOINT
        if [[ -z "$nilrt_path" ]]; then
            echo "Formatting $TARGET_DISK $NILRT_LABEL partition..."
            do_silent partition_format $TARGET_DISK $NILRT_LABEL
            nilrt_path=`lsblk -rpn $TARGET_DISK -o NAME,LABEL | grep " $NILRT_LABEL"'$'  | tail -1 | cut -d' ' -f1`
        else
            echo "Formatting $nilrt_path partition..."
            existing_nilrt_partition_format "$nilrt_path" "$uuid" "$nilrt_label"
        fi

        do_silent echo "Mounting $nilrt_path partition..."
        NILRT_ERROR=`mount "$nilrt_path" $NILRT_MOUNTPOINT` || die "$NILRT_ERROR"

        echo "Deploying minimal image..."

        # NOTE: `--numeric-owner` option: always use numbers for user/group names (ignore symbolic names)
        TAR_ERROR="`tar -x -j --numeric-owner -f /payload/factory-image.tar.bz2 -C $NILRT_MOUNTPOINT 2>&1`" || die "$TAR_ERROR"

        nilrt_part_uuid=`lsblk -rn $nilrt_path -o PARTUUID`
        if [[ -n "$nilrt_part_uuid" ]]; then
            # grub from nilrt partition needs PARTUUID to boot kernel from same partition
            root_partition_value="PARTUUID=$nilrt_part_uuid"
        else
            root_partition_value="$nilrt_path"
        fi

        mkdir -p $NILRT_MOUNTPOINT/boot/grub
        grub-editenv $NILRT_MOUNTPOINT/boot/grub/grubenv set root_partition_name="$root_partition_value"
        sync
        umount $NILRT_MOUNTPOINT || die "Failed to umount $NILRT_MOUNTPOINT"

        echo "Minimal image deployed."
        ASK_BEFORE_REBOOT=1
    }

    provision_target()
    {
        if [[ $restore == "backward-migrate" ]]; then
            source /ni_provisioning.safemode
            ASK_BEFORE_REBOOT=1
            return
        elif [ $restore == "migrate" ]; then
            mkdir -p $TEMP_MOUNTPOINT
            mkdir -p $BOOTFS_MOUNTPOINT
            older_nilrt_nibootfs_path=`lsblk -rpn $TARGET_DISK -o NAME,LABEL | grep " $OLDER_NILRT_NIBOOTFS_LABEL"'$' | tail -1 | cut -d' ' -f1`
            do_silent echo "Mounting $older_nilrt_nibootfs_path $OLDER_NILRT_NIBOOTFS_LABEL partition..."
            do_silent mount $older_nilrt_nibootfs_path $TEMP_MOUNTPOINT 2>&1 || die "Couldn't mount NIRECOVERY partition!"
            cp -r $TEMP_MOUNTPOINT/.newNILinuxRT/* $BOOTFS_MOUNTPOINT/
            do_silent umount $TEMP_MOUNTPOINT || die "Failed to umount $TEMP_MOUNTPOINT"
            SOURCE_DIR=$BOOTFS_MOUNTPOINT
        elif [ "$1" = "usb" ]; then
            mkdir -p $USB_MOUNTPOINT
            mount -o ro -L NIRECOVERY $USB_MOUNTPOINT 2>&1 || die "Couldn't mount NIRECOVERY partition!"
            SOURCE_DIR=$USB_MOUNTPOINT
        fi

        echo "Installing restore to: $TARGET_DISK using $BOOT_STYLE boot style."

        echo "Partitioning $TARGET_DISK..."
        do_silent disk_setup $TARGET_DISK

        #install grub

        GRUB_MOUNTPOINT=/var/volatile/grub
        mkdir -p $GRUB_MOUNTPOINT
        nigrub_path=`lsblk -rpn $TARGET_DISK -o NAME,LABEL | grep " $NIGRUB_LABEL"'$' | tail -1 | cut -d' ' -f1`
        do_silent echo "Mounting $nigrub_path $NIGRUB_LABEL partition..."
        MOUNT_ERROR=`mount $nigrub_path $GRUB_MOUNTPOINT 2>&1` || die "$MOUNT_ERROR"

        # Always configure for UEFI boot
        EFI_GRUB_TARGET_DIR=$GRUB_MOUNTPOINT/efi/boot
        mkdir -p $EFI_GRUB_TARGET_DIR
        cp -r $SOURCE_DIR/EFI/BOOT/* $EFI_GRUB_TARGET_DIR/

        if [[ $BOOT_STYLE == "efi" ]]; then
        echo "Configuring EFI grub2..."
        for ENTRY in `efibootmgr | grep "LabVIEW RT"| egrep -o '[0-9A-F]{4}' || true`
        do
        EFIMGR=`efibootmgr -b $ENTRY -B 2>&1` || print_warning "efibootmgr -b $ENTRY -B failed with: $EFIMGR"
        done
        do_silent efibootmgr -c -d ${TARGET_DISK} -p 1 -L 'LabVIEW RT' -l '\efi\boot\bootx64.efi'
        else
        echo "Configuring legacy grub2..."
        LEGACY_GRUB_TARGET_DIR=$GRUB_MOUNTPOINT/boot/grub
        parted -s ${TARGET_DISK} set 1 boot on
        grub-install --recheck --root-directory=$GRUB_MOUNTPOINT $TARGET_DISK
        cp /grub.cfg ${LEGACY_GRUB_TARGET_DIR}/grub.cfg
        fi

        echo "Installing kernel and ramdisk..."

        cp /grub.cfg ${EFI_GRUB_TARGET_DIR}/grub.cfg

        #install restore kernel and ramdisk
        RESTORE_MOUNTPOINT=/var/volatile/restore
        mkdir -p $RESTORE_MOUNTPOINT
        nirestore_path=`lsblk -rpn $TARGET_DISK -o NAME,LABEL | grep " $NIRESTORE_LABEL"'$' | tail -1 | cut -d' ' -f1`
        do_silent echo "Mounting $nirestore_path $NIRESTORE_LABEL partition..."
        RESTORE_ERROR=`mount $nirestore_path $RESTORE_MOUNTPOINT 2>&1` || die "$RESTORE_ERROR"

        cp $SOURCE_DIR/bzImage $RESTORE_MOUNTPOINT/
        cp $SOURCE_DIR/initrd $RESTORE_MOUNTPOINT/ramdisk
        sync

        restore_minimal_image

        sync
        umount $RESTORE_MOUNTPOINT || die "Failed to umount $RESTORE_MOUNTPOINT"
        umount $GRUB_MOUNTPOINT || die "Failed to umount $GRUB_MOUNTPOINT"
        if [ "$1" = "usb" ]; then
        umount $USB_MOUNTPOINT || die "Failed to umount $USB_MOUNTPOINT"
        fi

        provision_sucessfull
        ASK_BEFORE_REBOOT=1
    }
fi

#common functions for both architectures with little differences

print_verbose()
{
    if [[ $verbose_mode -eq 1 ]]; then
        echo -e $@
    fi
}

print_warning()
{
    print_verbose "${YELLOW}\n***Warning: $1\n${NC}"
}

install_default_error_handler()
{
    trap 'handle_err ${BASH_SOURCE} ${LINENO} ${FUNCNAME:-unknown} $? "$BASH_COMMAND"' ERR
}

handle_err()
{
    TMP_EVAL=`eval echo $5`
    die "$1:$2 (fn=$3): Unexpected status code $4, while running command: '$TMP_EVAL'"
}

get_time_delta()
{
    local offset="$1"
    local timestamp=$(date +%s)
    timestamp=$(( $timestamp - $offset ))
    echo "$timestamp"
}

early_setup()
{
    install_default_error_handler

    exec 3>&1
    exec 4>&2

    LOG_LEVEL=`cut -f1 /proc/sys/kernel/printk`

    OPTIND=1

    while getopts "havt:r:c:b:" opt; do
        case "$opt" in
            h)  show_help
                exit 1
                ;;
            a)  ask_at_every_error="y"
                ;;
            v)  verbose_mode=1
                >&3 echo "Verbose mode..."
                ;;
            t)  TARGET_DISK="$OPTARG"
                ;;
            r)  if [ "$OPTARG" == "y" -o "$OPTARG" == "Y" ]; then
                    use_ramfs=true
                elif [ "$OPTARG" == "n" -o "$OPTARG" == "N" ]; then
                    use_ramfs=false
                else
                    die "Must specify '-r y' or '-r n'"
                fi
                ;;
            c)  if [ "$OPTARG" == "y" -o "$OPTARG" == "Y" ]; then
                    grubenv_consoleoutenable="True"
                elif [ "$OPTARG" == "n" -o "$OPTARG" == "N" ]; then
                    grubenv_consoleoutenable="False"
                else
                    die "Must specify '-c y' or '-c n'"
                fi
                ;;
            b)  grubenv_bootdelay="$OPTARG"
                ;;
            *)  show_help
                exit 1
                ;;
        esac
    done

    shift $((OPTIND-1))

    [ "$1" = "--" ] && shift

    if [[ $verbose_mode -eq 1 ]]; then
        VERBOSE_ARGS="-v"
        MKFS_ARGS="$VERBOSE_ARGS -F"
    fi

    if [[ -z $TARGET_DISK ]]; then
        local search_begin="`get_time_delta 0`"
        while [ "`get_time_delta "$search_begin"`" -le "$TARGET_DISK_SEARCH_TIME" ]; do
            (( verbose_mode )) && echo "Searching for TARGET_DISK..." >&2
            TARGET_DISK="`find_target_block_device`" || TARGET_DISK=""
            if [[ -z $TARGET_DISK ]]; then
                (( verbose_mode )) && echo "not found" >&2
                sleep 1
            else
                (( verbose_mode )) && echo "found TARGET_DISK=$TARGET_DISK" >&2
                break
            fi
        done

        if [[ -z $TARGET_DISK ]]; then
            die "No target device found for installation after $TARGET_DISK_SEARCH_TIME seconds."
        fi
    else
        if [[ ! -e $TARGET_DISK ]]; then
        >&4 echo -e ${red}"Error: DEVICE $TARGET_DISK does not exist."${NC}
            show_help
            exit 1
        fi
    fi

    # separate partition number from block device names ending in a digit
    PART_SEPARATOR=''
    if [[ "${TARGET_DISK: -1}" =~ [0-9] ]]; then
        PART_SEPARATOR='p'
    fi

    if [[ -d "/sys/firmware/efi" ]]; then
        BOOT_STYLE="efi"
    else
        BOOT_STYLE="legacy"
    fi
}

check_answer_file()
{
    local filePath="$1"
    if [ -r "$filePath" ]; then
        # Answer file may only contain lines beginning with '#' or 'PROVISION_*=' variables
        if [ "`head -1 "$filePath"`" == "#NI_PROVISIONING_ANSWERS_V1" ]; then
            if ! egrep -q -v '(^$|^#|^PROVISION_[A-Z0-9_]+=)' "$filePath"; then
                return 0
            fi
        fi
    fi
    return 1
}

source_default_answer_file()
{
    if ! check_answer_file "/ni_provisioning.answers.default"; then
        die "Missing or corrupt file /ni_provisioning.answers.default"
    fi
    source "/ni_provisioning.answers.default"
}

source_answer_file()
{
    print_verbose "Searching for answer files:"

    # first check for embedded answer file on the boot disk
    if check_answer_file "/ni_provisioning.answers"; then
        print_verbose "Using embedded answer file at /ni_provisioning.answers"
        source "/ni_provisioning.answers"
        return
    fi

    mkdir -p "$ANSWER_FILE_DISK_MOUNTPOINT"
    for devNode in `lsblk -rpn -o NAME,TYPE,RM | grep -E 'part|rom 1$' | cut -d' ' -f1 || true`; do
        devNodeInfo="`lsblk -n -o 'FSTYPE,SERIAL,UUID,LABEL' "$devNode" | tr -s ' '`"
        mount -o ro "$devNode"  "$ANSWER_FILE_DISK_MOUNTPOINT"
        if check_answer_file    "$ANSWER_FILE_DISK_MOUNTPOINT/ni_provisioning.answers"; then
            print_verbose "Using ni_provisioning.answers on $devNode ($devNodeInfo)"
            source              "$ANSWER_FILE_DISK_MOUNTPOINT/ni_provisioning.answers"
            return
        else
            umount              "$ANSWER_FILE_DISK_MOUNTPOINT"
            print_verbose "Skipped $devNode ($devNodeInfo)"
            # and keep going
        fi
    done

    print_verbose "No answer file found; using default configuration"
}

prompt_user()
{
    local question="$1"
    local answerPattern="$2"
    local defaultAnswer="$3"
    local -n var="$4"
    if [[ $var == "?" ]]; then
        while [[ ! $var =~ $answerPattern ]]; do
            read -p "$question: " var
            var="${var,,}"  #lowercase var
            if [[ -z "$var" ]]; then
                var="$defaultAnswer"
            fi
        done
    else
        echo "$question: $var (auto)"
    fi
}
