#!/bin/bash
#this file contains the functions needed by the provisioning tool

REBOOT_REQUIRED=0
ANSWER_FILE_DISK_MOUNTPOINT=/var/volatile/answerFileDisk
USB_MOUNTPOINT=/var/volatile/usbrtdeploy
NILRT_MOUNTPOINT=/var/volatile/nilrt
NIRESTORE_MOUNTPOINT=/var/volatile/nirestore
NICONFIG_MOUNTPOINT=/var/volatile/niconfig
GRUB_MOUNTPOINT=/var/volatile/nigrub
BOOTFS_MOUNTPOINT=/var/volatile/nibootfs
ROOTFS_MOUNTPOINT=/var/volatile/nirootfs
TEMP_MOUNTPOINT=/var/volatile/temp_dir
NIGRUB_LABEL=nigrub
NIRESTORE_LABEL=nirestore
NILRT_LABEL=nilrt
OLDER_NILRT_NIBOOTFS_LABEL=nibootfs
LOG_LEVEL=7

ARCH=`uname -m`

if $(grep -qF ni_silent_provision /proc/cmdline); then
    do_silent() { "$@" &>/dev/null; };
else
    do_silent() { "$@"; }
fi

cleanup_and_exit()
{
    echo $LOG_LEVEL > /proc/sys/kernel/printk
    trap - ERR

    sync

    umount "$ANSWER_FILE_DISK_MOUNTPOINT" 2>/dev/null
    umount -a -t vfat,ext4,ubifs,iso9660

    if [ "$ARCH" = "armv7l" ]; then
        #set the bootmode to default
        echo -n 00 >  /sys/bus/i2c/devices/0-0040/scratch_hardreset
    fi

    if (( $1 == 0  && $REBOOT_REQUIRED == 1 )); then
        echo "Unmounting all file systems:"
        umount -v -a -r  # procfs is not unmounted
        echo u > /proc/sysrq-trigger
        sync

        if [[ "${PROVISION_REBOOT_METHOD,,}" == "reboot" ]]; then
            echo "Rebooting"
            reboot -f
            sleep 1
            echo b > /proc/sysrq-trigger
            sleep 1
        elif [[ "${PROVISION_REBOOT_METHOD,,}" == "poweroff" ]]; then
            echo "Powering off"
            poweroff -f
            sleep 1
            echo o > /proc/sysrq-trigger
            sleep 1
        else
            echo "Dropping to shell"
        fi
    fi

    exit $1
}

die()
{
    printf "\n***Error: %s\n" "$1"
    printf "PROVISIONING FAILED!"
    cleanup_and_exit 1
}

if [ -e /disk_config ]; then
    source /disk_config
else
    die "disk_config not found!"
fi

if [ "$ARCH" = "armv7l" ]; then

    restore_minimal_image()
    {
        echo "Formatting ubi1:rootfs..."
        format_ubi_volume root 0 rootfs
        echo "Done"
        mkdir -p $NILRT_MOUNTPOINT
        mkdir -p $NIRESTORE_MOUNTPOINT
        MOUNT_ERROR=`mount -t ubifs ubi1:rootfs $NILRT_MOUNTPOINT` || die "$MOUNT_ERROR"
        echo "Deploying minimal image..."
        # NOTE: `--numeric-owner` option: always use numbers for user/group names (ignore symbolic names)
        TAR_ERROR="`tar -x -j --numeric-owner -f /payload/factory-image.tar.bz2 -C $NILRT_MOUNTPOINT 2>&1`" || die "$TAR_ERROR"
        cp /payload/*.scr $NILRT_MOUNTPOINT/boot/
        ln -sf $NILRT_MOUNTPOINT/boot/uImage-* /boot/uImage
        MOUNT_ERROR=`mount -t ubifs ubi0:bootfs $NIRESTORE_MOUNTPOINT` || die "$MOUNT_ERROR"
        cp $NIRESTORE_MOUNTPOINT/.restore/ni-*.dtb $NILRT_MOUNTPOINT/boot/
        cp /payload/linux_next_runmode.itb $NIRESTORE_MOUNTPOINT/linux_runmode.itb
        sync
        umount $NILRT_MOUNTPOINT || die "Failed to umount $NILRT_MOUNTPOINT"
        umount $NIRESTORE_MOUNTPOINT || die "Failed to umount $NIRESTORE_MOUNTPOINT"
        echo "Minimal image deployed."
        REBOOT_REQUIRED=1
        echo "PROVISIONING SUCCESSFUL!"
    }

    provision_target()
    {
        mkdir -p $NILRT_MOUNTPOINT
        mkdir -p $NIRESTORE_MOUNTPOINT
        mkdir -p $NICONFIG_MOUNTPOINT
        mkdir -p $TEMP_MOUNTPOINT

        MOUNT_ERROR=`mount -t ubifs ubi1:rootfs $NILRT_MOUNTPOINT` || die "$MOUNT_ERROR"
        MOUNT_ERROR=`mount -t ubifs ubi0:bootfs $NIRESTORE_MOUNTPOINT` || die "$MOUNT_ERROR"
        MOUNT_ERROR=`mount -t ubifs ubi0:config $NICONFIG_MOUNTPOINT` || die "$MOUNT_ERROR"
        DEVICE_CODE=`fw_printenv -n DeviceCode`

        if [[ $restore == "migrate" ]]; then
            #replace the linux_safemode.itb with the fake one
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.safe/linux_next_safemode.itb $NIRESTORE_MOUNTPOINT/.safe/linux_safemode.itb
            #copy all the necessary files for restore-mode
            mkdir -p $NIRESTORE_MOUNTPOINT/.restore
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.restore/dtbs/ni-$DEVICE_CODE.dtb $NIRESTORE_MOUNTPOINT/.restore/ || die "ni-$DEVICE_CODE.dtb file not found!"
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.restore/uImage $NIRESTORE_MOUNTPOINT/.restore/ || die "Kernel not found!"
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.restore/ramdisk $NIRESTORE_MOUNTPOINT/.restore/ || die "Ramdisk not found!"
            cp $NILRT_MOUNTPOINT/.newNILinuxRT/.restore/restore.scr $NIRESTORE_MOUNTPOINT/.restore/ || die "Restore script not found!"

            #clear config contents which are unused in newer versions of NILRT
            rm -rf $NICONFIG_MOUNTPOINT/*

            sync
            umount $NILRT_MOUNTPOINT || die "Failed to umount $NILRT_MOUNTPOINT"
            umount $NIRESTORE_MOUNTPOINT || die "Failed to umount $NIRESTORE_MOUNTPOINT"
            umount $NICONFIG_MOUNTPOINT || die "Failed to umount $NICONFIG_MOUNTPOINT"

            restore_minimal_image

        elif [[ $restore == "backward-migrate" ]]; then

            printf "Removing the already installed nilrt... "
            rm -rf $NIRESTORE_MOUNTPOINT/.safe
            rm -rf $NIRESTORE_MOUNTPOINT/.restore
            rm -rf $NIRESTORE_MOUNTPOINT/.defbit
            rm -f $NIRESTORE_MOUNTPOINT/linux_runmode.itb
            echo "done."

            printf "Deploying older NILRT version safemode on target... "
            mkdir -p $NIRESTORE_MOUNTPOINT/.safe
            mkdir -p $NIRESTORE_MOUNTPOINT/.defbit

            NON_HEX_DEV_CODE=$(echo $DEVICE_CODE | awk '{print substr($0,3)}')
            DEVCFG_PATH=$NILRT_MOUNTPOINT/$NON_HEX_DEV_CODE

            mkdir -p $DEVCFG_PATH/cfg-contents
            mkdir -p $DEVCFG_PATH/cfg-contents/bitfiles-contents

            # NOTE: `--no-same-owner` option: extract files as current user (default for ordinary users)
            tar -x --no-same-owner -f $DEVCFG_PATH/*.cfg -C $DEVCFG_PATH/cfg-contents/ || die "Could not extract cfg from $NILRT_MOUNTPOINT/$NON_HEX_DEV_CODE"
            tar -x --no-same-owner -f $DEVCFG_PATH/cfg-contents/bitfiles.tgz -C $DEVCFG_PATH/cfg-contents/bitfiles-contents/ || die "Could not extract bitfiles.tgz"

            cp $DEVCFG_PATH/cfg-contents/linux_safemode.itb $NIRESTORE_MOUNTPOINT/.safe/linux_safemode.itb || die "linux_safemode.itb not found"

            if [ -d "$DEVCFG_PATH/cfg-contents/bitfiles-contents/$DEVICE_CODE" ]; then
                cp $DEVCFG_PATH/cfg-contents/bitfiles-contents/$DEVICE_CODE/default.bit.* $NIRESTORE_MOUNTPOINT/.defbit/
            else
                cp $DEVCFG_PATH/cfg-contents/bitfiles-contents/default.bit.* $NIRESTORE_MOUNTPOINT/.defbit/
            fi
            echo "done."

            sync
            umount $NILRT_MOUNTPOINT || die "Failed to umount $NILRT_MOUNTPOINT"
            umount $NIRESTORE_MOUNTPOINT || die "Failed to umount $NIRESTORE_MOUNTPOINT"
            umount $NICONFIG_MOUNTPOINT || die "Failed to umount $NICONFIG_MOUNTPOINT"

            printf "Formatting ubi1:rootfs... "
            format_ubi_volume root 0 rootfs
            echo "done."

            REBOOT_REQUIRED=1
            echo "PROVISIONING SUCCESSFUL!"
        fi
    }

elif [ "$ARCH" = "x86_64" ]; then

    show_help()
    {
cat <<EOF
    Usage: $0 [-h] [-t DEVICE]
    Options
        -h : Show help.
        -t DEVICE : DEVICE is the device name for the disk to update. (e.g /dev/sda)
        If DEVICE is not specificed, the first non-removable block device
        that is not the recovery tool is used.
EOF
    }

    find_target_block_device()
    {
        lsblk -inpo KNAME,TYPE,RM | while read KNAME TYPE RM; do
            if [[ $TYPE == "disk" && $RM == "0" ]]; then
                echo $KNAME
                break;
            fi
        done
    }

    restore_minimal_image()
    {
        local nilrt_path="$1" uuid="$2" nilrt_label="$3"

        NILRT_MOUNTPOINT=/var/volatile/nilrt
        mkdir -p $NILRT_MOUNTPOINT
        if [[ -z "$nilrt_path" ]]; then
            echo "Formatting $TARGET_DISK $NILRT_LABEL partition..."
            do_silent partition_format $TARGET_DISK $NILRT_LABEL
            nilrt_path=`lsblk -rpn $TARGET_DISK -o NAME,LABEL | grep " $NILRT_LABEL"'$'  | tail -1 | cut -d' ' -f1`
        else
            echo "Formatting $nilrt_path partition..."
            existing_nilrt_partition_format "$nilrt_path" "$uuid" "$nilrt_label"
        fi

        do_silent echo "Mounting $nilrt_path partition..."
        NILRT_ERROR=`mount "$nilrt_path" $NILRT_MOUNTPOINT` || die "$NILRT_ERROR"

        echo "Deploying minimal image..."

        # NOTE: `--numeric-owner` option: always use numbers for user/group names (ignore symbolic names)
        TAR_ERROR="`tar -x -j --numeric-owner -f /payload/factory-image.tar.bz2 -C $NILRT_MOUNTPOINT 2>&1`" || die "$TAR_ERROR"

        nilrt_part_uuid=`lsblk -rn $nilrt_path -o PARTUUID`
        if [[ -n "$nilrt_part_uuid" ]]; then
            # grub from nilrt partition needs PARTUUID to boot kernel from same partition
            root_partition_value="PARTUUID=$nilrt_part_uuid"
        else
            root_partition_value="$nilrt_path"
        fi

        mkdir -p $NILRT_MOUNTPOINT/boot/grub
        grub-editenv $NILRT_MOUNTPOINT/boot/grub/grubenv set root_partition_name="$root_partition_value"
        sync
        umount $NILRT_MOUNTPOINT || die "Failed to umount $NILRT_MOUNTPOINT"

        echo "Minimal image deployed."
        REBOOT_REQUIRED=1
    }

    provision_target()
    {
        if [ "$1" = "usb" ]; then
            mkdir -p $USB_MOUNTPOINT
            mount -o ro -L NIRECOVERY $USB_MOUNTPOINT 2>&1 || die "Couldn't mount NIRECOVERY partition!"
            SOURCE_DIR=$USB_MOUNTPOINT
        elif [ "$1" = "onboard" ]; then
            # only migrate and backward-migrate use cases, using older NI Linux RT nibootfs partition
            mkdir -p $TEMP_MOUNTPOINT
            mkdir -p $BOOTFS_MOUNTPOINT
            older_nilrt_nibootfs_path=`lsblk -rpn $TARGET_DISK -o NAME,LABEL | grep " $OLDER_NILRT_NIBOOTFS_LABEL"'$' | tail -1 | cut -d' ' -f1`
            do_silent echo "Mounting $older_nilrt_nibootfs_path $OLDER_NILRT_NIBOOTFS_LABEL partition..."
            mount $older_nilrt_nibootfs_path $TEMP_MOUNTPOINT 2>&1 || die "Couldn't mount NIRECOVERY partition!"
            cp -r $TEMP_MOUNTPOINT/.newNILinuxRT/* $BOOTFS_MOUNTPOINT/
            umount $TEMP_MOUNTPOINT || die "Failed to umount $TEMP_MOUNTPOINT"
            SOURCE_DIR=$BOOTFS_MOUNTPOINT
        fi

        echo "Installing restore to: $TARGET_DISK using $BOOT_STYLE boot style."

        echo "Partitioning $TARGET_DISK..."
        do_silent disk_setup $TARGET_DISK

        #install grub

        GRUB_MOUNTPOINT=/var/volatile/grub
        mkdir -p $GRUB_MOUNTPOINT
        nigrub_path=`lsblk -rpn $TARGET_DISK -o NAME,LABEL | grep " $NIGRUB_LABEL"'$' | tail -1 | cut -d' ' -f1`
        do_silent echo "Mounting $nigrub_path $NIGRUB_LABEL partition..."
        MOUNT_ERROR=`mount $nigrub_path $GRUB_MOUNTPOINT 2>&1` || die "$MOUNT_ERROR"

        # Always configure for UEFI boot
        EFI_GRUB_TARGET_DIR=$GRUB_MOUNTPOINT/efi/boot
        mkdir -p $EFI_GRUB_TARGET_DIR
        cp -r $SOURCE_DIR/EFI/BOOT/* $EFI_GRUB_TARGET_DIR/

        if [[ $BOOT_STYLE == "efi" ]]; then
            echo "Configuring EFI grub2..."
            for ENTRY in `efibootmgr | grep "LabVIEW RT"| egrep -o '[0-9A-F]{4}' || true`
            do
            EFIMGR=`efibootmgr -b $ENTRY -B 2>&1` || print_warning "efibootmgr -b $ENTRY -B failed with: $EFIMGR"
            done
            do_silent efibootmgr -c -d ${TARGET_DISK} -p 1 -L 'LabVIEW RT' -l '\efi\boot\bootx64.efi'
        else
            echo "Configuring legacy grub2..."
            LEGACY_GRUB_TARGET_DIR=$GRUB_MOUNTPOINT/boot/grub
            parted -s ${TARGET_DISK} set 1 boot on
            grub-install --recheck --root-directory=$GRUB_MOUNTPOINT $TARGET_DISK
            cp /grub.cfg ${LEGACY_GRUB_TARGET_DIR}/grub.cfg
        fi

        echo "Installing kernel and ramdisk..."

        cp /grub.cfg ${EFI_GRUB_TARGET_DIR}/grub.cfg

        #install restore kernel and ramdisk
        RESTORE_MOUNTPOINT=/var/volatile/restore
        mkdir -p $RESTORE_MOUNTPOINT
        nirestore_path=`lsblk -rpn $TARGET_DISK -o NAME,LABEL | grep " $NIRESTORE_LABEL"'$' | tail -1 | cut -d' ' -f1`
        do_silent echo "Mounting $nirestore_path $NIRESTORE_LABEL partition..."
        RESTORE_ERROR=`mount $nirestore_path $RESTORE_MOUNTPOINT 2>&1` || die "$RESTORE_ERROR"

        cp $SOURCE_DIR/bzImage $RESTORE_MOUNTPOINT/
        cp $SOURCE_DIR/initrd $RESTORE_MOUNTPOINT/ramdisk
        sync

        restore_minimal_image

        sync
        umount $RESTORE_MOUNTPOINT || die "Failed to umount $RESTORE_MOUNTPOINT"
        umount $GRUB_MOUNTPOINT || die "Failed to umount $GRUB_MOUNTPOINT"
        if [ "$1" = "usb" ]; then
            umount $USB_MOUNTPOINT || die "Failed to umount $USB_MOUNTPOINT"
        fi

        echo ""
        echo "PROVISIONING SUCCESSFUL!"
        REBOOT_REQUIRED=1
    }

fi

#common functions for both architectures with little differences

print_warning()
{
    printf "\n***Warning: %s\n" "$1"
}

install_default_error_handler()
{
    trap 'handle_err ${BASH_SOURCE} ${LINENO} ${FUNCNAME:-unknown} $? "$BASH_COMMAND"' ERR
}

handle_err()
{
    TMP_EVAL=`eval echo $5`
    die "$1:$2 (fn=$3): Unexpected status code $4, while running command: '$TMP_EVAL'"
}

early_setup()
{
    install_default_error_handler
    LOG_LEVEL=`cut -f1 /proc/sys/kernel/printk`
    echo 6 > /proc/sys/kernel/printk

    if [ "$ARCH" = "x86_64" ]; then
        OPTIND=1

        while getopts "ht:" opt; do
            case "$opt" in
                h)  show_help
                    exit 1
                    ;;
                t)  TARGET_DISK=$OPTARG
                    ;;
                *)  show_help
                    exit 1
                    ;;
            esac
        done

        shift $((OPTIND-1))

        [ "$1" = "--" ] && shift

        if [[ -z $TARGET_DISK ]]; then
            TARGET_DISK=`find_target_block_device`
            if [[ -z $TARGET_DISK ]]; then
                die "No target device found for installation."
            fi
        else
            if [[ ! -e $TARGET_DISK ]]; then
                echo "Error: DEVICE $TARGET_DISK does not exist."
                show_help
                exit 1
            fi
        fi

        if [[ -d "/sys/firmware/efi" ]]; then
            BOOT_STYLE="efi"
        else
            BOOT_STYLE="legacy"
        fi
    fi
}

check_answer_file()
{
    local filePath="$1"
    if [ -r "$filePath" ]; then
        # Answer file may only contain lines beginning with '#' or 'PROVISION_*=' variables
        if [ "`head -1 "$filePath"`" == "#NI_PROVISIONING_ANSWERS_V1" ]; then
            if ! egrep -q -v '(^$|^#|^PROVISION_[A-Z0-9_]+=)' "$filePath"; then
                return 0
            fi
        fi
    fi
    return 1
}

source_default_answer_file()
{
    if ! check_answer_file "/ni_provisioning.answers.default"; then
        die "Missing or corrupt file /ni_provisioning.answers.default"
    fi
    source "/ni_provisioning.answers.default"
}

source_answer_file()
{
    echo "Searching for answer files:"

    # first check for embedded answer file on the boot disk
    if check_answer_file "/ni_provisioning.answers"; then
        echo "Using embedded answer file at /ni_provisioning.answers"
        source "/ni_provisioning.answers"
        return
    fi

    mkdir -p "$ANSWER_FILE_DISK_MOUNTPOINT"
    for devNode in `lsblk -rpn -o NAME,TYPE,RM | grep 'part 1$' | cut -d' ' -f1 || true`; do
        devNodeInfo="`lsblk -n -o 'FSTYPE,SERIAL,UUID,LABEL' "$devNode" | tr -s ' '`"
        mount -o ro "$devNode"  "$ANSWER_FILE_DISK_MOUNTPOINT"
        if check_answer_file    "$ANSWER_FILE_DISK_MOUNTPOINT/ni_provisioning.answers"; then
            echo "Using ni_provisioning.answers on $devNode ($devNodeInfo)"
            source              "$ANSWER_FILE_DISK_MOUNTPOINT/ni_provisioning.answers"
            return
        else
            umount              "$ANSWER_FILE_DISK_MOUNTPOINT"
            echo "Skipped $devNode ($devNodeInfo)"
            # and keep going
        fi
    done

    echo "No answer file found; using default configuration"
}

prompt_user()
{
    local question="$1"
    local answerPattern="$2"
    local defaultAnswer="$3"
    local -n var="$4"
    if [[ $var == "?" ]]; then
        while [[ ! $var =~ $answerPattern ]]; do
            read -p "$question: " var
            var="${var,,}"  #lowercase var
            if [[ -z "$var" ]]; then
                var="$defaultAnswer"
            fi
        done
    else
        echo "$question: $var (auto)"
    fi
}
