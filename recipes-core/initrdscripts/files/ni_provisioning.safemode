#!/bin/bash
set -e

RECOVERYTOOL_VERSION=""
USB_MOUNTPOINT=/var/volatile/usbrtdeploy
ONBOARD_SOURCE=/var/volatile/source_dir
red='\e[0;31m'
NC='\e[0m'
yellow='\e[1;33m'
verbose_mode=0
ask_at_every_error="N"
use_ramfs=""
grubenv_consoleoutenable=""
grubenv_bootdelay=""

. /usr/share/nisysinfo/smbios_helper

print_info()
{
    if [ $verbose_mode -eq 1 ]; then
        >&3 echo $1
    else
        >&3 echo -n $1
    fi
}

print_verbose()
{
    if [[ $verbose_mode -eq 1 ]]; then
        echo $1
    fi
}

cleanup()
{
    umount $USB_MOUNTPOINT || true
    sync || true
}

cleanup_and_exit()
{
    cleanup
    exit $1
}

print_warning()
{
    >&4 echo -e ${yellow}"\n***Warning: $1\n"${NC}
}

print_error()
{
    >&4 echo -e ${red}"\n***Error: $1\n"${NC}
	local continue_on_error="N"
    if [[ "$ask_at_every_error" == "y" ]]; then
        exec 2>&4
        read -p "Do you want to ignore this error?[y/N]" continue_on_error
		exec 4>&2
	fi
	if [[ "$continue_on_error" == "N" || "$continue_on_error" == "n" || "$continue_on_error" == "" ]]; then
        >&4 echo -e ${red}"PROVISIONING FAILED!"${NC}
        cleanup_and_exit 1
    fi
}

die()
{
    >&4 echo -e ${red}"\n***Fatal Error: $1"${NC}
    >&4 echo -e ${red}"PROVISIONING FAILED!"${NC}
    cleanup_and_exit 1
}

print_done()
{
    if [ $verbose_mode -eq 0 ]; then
        >&3 echo "Done"
    fi
}

show_help()
{
    >&3 echo -e "\nUsage: $0 [-hav] [-t DEVICE]\n"
    >&3 echo -e "Options\n"
    >&3 echo "   -h : Show help."
    >&3 echo "   -a : Ask at every error if continue. Default is N, so at the first error abort."
    >&3 echo "   -v : Verbose mode."
    >&3 echo "   -t DEVICE : DEVICE is the device name for the disk to update. (e.g /dev/sda)"
    >&3 echo "               If DEVICE is not specificed, the first non-removable block device"
    >&3 echo "               that is not the recovery tool is used."
    >&3 echo "   -r y|n : Force use of initramfs style boot for runmode (compatible 2018 and later)."
    >&3 echo "            Also enables bootflag.d directory for bootmode selection. Determined"
    >&3 echo "            automatically when unspecified."
    >&3 echo "   -c y|n : Initial value of the console out enable flag."
    >&3 echo "   -b SECONDS : Initial value of bootdelay -- how long (seconds) to show boot menu."
}

disable_automount()
{
    echo -e $TARGET_DISK >> /etc/udev/mount.blacklist
    AUTOMOUNT_DISABLED=1
}

enable_automount()
{
    sed -ie "\#$TARGET_DISK#d" /etc/udev/mount.blacklist
    AUTOMOUNT_DISABLED=0
}
#waits until the four partitions are visible
wait_for_partitions()
{
    DEVICE_TMP=$1
    for i in 1 2 3 4
    do
        #wait max 3 seconds for each partition
        print_verbose "Waiting for $DEVICE_TMP$i "
        MaxTries=30
        while [ ! -b ${DEVICE_TMP}${PART_SEPARATOR}$i -a $MaxTries -gt 0 ];
        do
            print_verbose "."
            #sleep 0.1 seconds
            usleep 100000
            MaxTries=$(($MaxTries - 1))
        done
        if [ $MaxTries -eq 0 ]; then
            return 1
        fi
    done
}

install_default_error_handler()
{
    trap 'handle_err ${BASH_SOURCE} ${LINENO} ${FUNCNAME:-unknown} $? "$BASH_COMMAND"' ERR
}

handle_err()
{
    TMP_EVAL=`eval echo $5`
    print_error "$1:$2 (fn=$3): Unexpected status code $4, while running command: '$TMP_EVAL'" ${NC}
}

umount_partitions()
{
    for PART in `ls -1 ${TARGET_DISK}* | tail -n +2`
    do
        if [ ! -z "`mount | grep $PART`" ]; then
            umount $PART
        fi
    done
}

check_all_used_binaries()
{
    commands=(dmidecode e2label hexdump lsblk mkfs.ext4 mkfs.vfat parted sed sfdisk sgdisk udevadm modprobe dd)
    for ind_command in ${commands[@]}; do
        one_command=`command -v ${ind_command}`
        if [[ -z $one_command ]]; then
            die "Command \"${ind_command}\" not found. Please install ${ind_command}."
        fi
    done

}

# For a given block device (represented by sysfs path $1 and block device path
# $2), return zero if suitable for provisioning.
check_block_device () {
    local path=$1 block=$2

    if ! (( $? == 0 )); then
        (( verbose_mode )) && echo "SKIPPED $path_abbrev: udevadm failed" >&2
        return 1
    fi

    # Skip zero-size devices. This catches unattached loop*.
    if ! (( $(<$path/size) > 0 )); then
        (( verbose_mode )) && echo "SKIPPED $path_abbrev: size==0" >&2
        return 1
    fi

    # Skip removable devices; we're only interested in internal disks. This
    # catches USBs and CDs.
    if ! (( $(<$path/removable) == 0 )); then
        (( verbose_mode )) && echo "SKIPPED $path_abbrev: removable!=0" >&2
        return 1
    fi

    # Skip read-only devices. This catches mmcblk*boot*, but *not*
    # CDs, unless a read-only CD is present in the drive.
    if ! (( $(<$path/ro) == 0 )); then
        (( verbose_mode )) && echo "SKIPPED $path_abbrev: ro!=0" >&2
        return 1
    fi

    # Skip purely virtual devices. This catches zram* and loop* (again).
    if ! [[ -d $path/device ]]; then
        (( verbose_mode )) && echo "SKIPPED $path_abbrev: no device/" >&2
        return 1
    fi

    # $path/device/block must exist. This catches mmcblk*boot* (again).
    if ! [[ -d $path/device/block/ ]]; then
        (( verbose_mode )) && echo "SKIPPED $path_abbrev: no device/block/" >&2
        return 1
    fi

    # Skip the recovery partition itself. Scan all partitions that might be present
    # at/underneath the given block device.
    for p in ${block}*; do
        local label=`lsblk $p -n -o LABEL 2>/dev/null`
        if [[ "$label" == "NIRECOVERY" ]]; then
            (( verbose_mode )) && echo "SKIPPED $path_abbrev: contains NIRECOVERY" >&2
            return 1
        fi
    done

    return 0
}

find_target_block_device()
{
   local selected_block=
    for path in /sys/block/*; do
        path_abbrev=${path##/sys/block/}
        local block=$(udevadm info -r --query=name --path=$path)
        check_block_device $path $block || continue

        # Looks good. Select the first device we see.
        if [[ $selected_block ]]; then
            (( verbose_mode )) && echo "SKIPPED block device $path_abbrev" >&2
        else
            selected_block=$block
            (( verbose_mode )) && echo "SELECTED block device $path_abbrev" >&2
        fi
    done
    if [[ $selected_block ]]; then
        echo "$selected_block"
    else
        echo "ERROR: No block device found" >&2
        return 1
    fi
}

override_primaryport_grubenv()
{
    # Add target-specific override of primary ethernet port if the lowest ifIndex is not to be used
    local device_code=$(get_target_id)
    # CVS-1458RT
    if [[ x"$device_code" == x"77AA" ]]; then
        # Set eth0 (note: renamed to eth0 via udev) as the primary port. Do not let the primary
        # port selection logic decide since it selects the 'eth' port with the lowest ifIndex
        # value. (Renaming the port via udev does not alter ifIndex, so eth0 is not the lowest)
        grub-editenv $BOOTFS_MOUNTPOINT/grub/grubenv set "ethaddr=`cat /sys/class/net/eth0/address`"
    fi
}

add_USB_gadget_args_to_grubenv()
{
    local MAC=$(get_usbdev_mac)
    local VID=$(get_usbdev_vid)
    local PID=$(get_usbdev_pid)
    local SN=$(get_serial_number)
    local TID=$(get_target_id)
    local PROD=$(get_target_name)
    
    if is_usbdev_target; then

        if [ -n "$MAC" -a -n "$VID" -a -n "$PID" -a -n "$SN" -a -n "$TID" -a -n "$PROD" ]; then
            cat << EOF > $GRUB_MOUNTPOINT/grubvar_readonly
set usbgadgetethaddr=$MAC
set USBVendorID=$VID
set USBProductID=$PID
set SerialNum=$SN
set USBDevice=$TID
set USBProduct=$PROD
EOF
        else
            print_error "Details required for USB device mode are missing from SMBIOS! UPGRADE your BIOS if using NI Target. USB Gadget will not be functional."
            return
        fi
    fi
}

set_serial_port()
{
    if [ -f /sys/class/tty/ttyS0/type -a `cat /sys/class/tty/ttyS0/type` -ne 0 ]; then
        echo "set serial_port="`cat /sys/class/tty/ttyS0/port` >> $GRUB_MOUNTPOINT/grubvar_readonly
    fi
}

# Load necessary kernel modules needed to inspect the system's hardware
load_kernel_modules ()
{
    for modname in "tpm_tis"; do
        if modprobe "$modname"; then
            print_verbose "Loaded $modname"
        else
            print_error "Failed to load $modname"
        fi
    done
}

# Is true if system has a TPM chip. Must not be used before
#  load_kernel_modules() runs.
has_tpm_chip ()
{
    [ -e "/dev/tpm0" ]
}

#############
#main script#
#############

install_default_error_handler

exec 3>&1
exec 4>&2

LOG_LEVEL=`cut -f1 /proc/sys/kernel/printk`

OPTIND=1

while getopts "havt:r:c:b:" opt; do
    case "$opt" in
        h)  show_help
            exit 1
            ;;
        a)  ask_at_every_error="y"
            ;;
        v)  verbose_mode=1
            >&3 echo "Verbose mode..."
            ;;
        t)  TARGET_DISK="$OPTARG"
            ;;
        r)  if [ "$OPTARG" == "y" -o "$OPTARG" == "Y" ]; then
                use_ramfs=true
            elif [ "$OPTARG" == "n" -o "$OPTARG" == "N" ]; then
                use_ramfs=false
            else
                die "Must specify '-r y' or '-r n'"
            fi
            ;;
        c)  if [ "$OPTARG" == "y" -o "$OPTARG" == "Y" ]; then
                grubenv_consoleoutenable="True"
            elif [ "$OPTARG" == "n" -o "$OPTARG" == "N" ]; then
                grubenv_consoleoutenable="False"
            else
                die "Must specify '-c y' or '-c n'"
            fi
            ;;
        b)  grubenv_bootdelay="$OPTARG"
            ;;
		*)  show_help
			exit 1
			;;	
    esac
done

shift $((OPTIND-1))

[ "$1" = "--" ] && shift

if [[ $verbose_mode -eq 0 ]]; then
    exec 1>/dev/null
    exec 2>/dev/null
    MKFS_ARGS="-q"
else
    MKFS_ARGS="-v"
fi

if [[ -z $TARGET_DISK ]]; then
    TARGET_DISK=`find_target_block_device`
    if [[ -z TARGET_DISK ]]; then
        die "No target device found for installation."
    fi
else
    if [[ ! -e $TARGET_DISK ]]; then
        >&4 echo -e ${red}"Error: DEVICE $TARGET_DISK does not exist."${NC}
        show_help
        exit 1
    fi
fi

#separate partition number from block device names ending in a digit
PART_SEPARATOR=''
if [[ "${TARGET_DISK: -1}" =~ [0-9] ]]; then
    PART_SEPARATOR='p'
fi

check_all_used_binaries
load_kernel_modules

# If use_ramfs was unspecified by user, set it based on
#  presence of TPM chip
if [ -z "$use_ramfs" ]; then
    if has_tpm_chip; then
        use_ramfs=true
    else
        use_ramfs=false
    fi
fi

if [[ -d "/sys/firmware/efi" ]]; then
    BOOT_STYLE="efi"
else
    BOOT_STYLE="legacy"
fi

echo "Installing safemode to: $TARGET_DISK using $BOOT_STYLE boot style."

echo 6 > /proc/sys/kernel/printk

SOURCE_DIR=/boot/.oldNILinuxRT

print_info "Partitioning $TARGET_DISK..."
PART1_LABEL=nigrub
PART2_LABEL=nibootfs
PART3_LABEL=niconfig
PART4_LABEL=nirootfs

print_done

# GPT partitions must assign a partition name whereas
# MSDOS partitions must assign a partition type (e.g. primary)
if [[ "$BOOT_STYLE" == "efi" ]]; then
    PART_STYLE=gpt
    PART1_NAME=$PART1_LABEL
    PART2_NAME=$PART2_LABEL
    PART3_NAME=$PART3_LABEL
    PART4_NAME=$PART4_LABEL
else
    PART_STYLE=msdos
    PART1_NAME=primary
    PART2_NAME=primary
    PART3_NAME=primary
    PART4_NAME=primary
fi

print_info "Disabling automount..."
disable_automount
print_done

print_info "Unmounting partitions..."
umount_partitions
print_done

print_info "Clearing TARGET_DISK=$TARGET_DISK..."
dd if="/dev/zero" of="$TARGET_DISK" bs=1048576 count=1 || die "Failed to zero first 1MB of disk"
sync
print_done

print_info "Partitioning TARGET_DISK=$TARGET_DISK (PART_STYLE=$PART_STYLE)..."
PARTED_ERROR=`parted -s $TARGET_DISK mklabel $PART_STYLE 2>&1` || die "$PARTED_ERROR"
PARTED_ERROR=`parted -s --align optimal $TARGET_DISK mkpart $PART1_NAME 1MB 16MB 2>&1` || die "$PARTED_ERROR"
PARTED_ERROR=`parted -s --align optimal $TARGET_DISK mkpart $PART2_NAME 16MB 200MB 2>&1` || die "$PARTED_ERROR"
PARTED_ERROR=`parted -s --align optimal $TARGET_DISK mkpart $PART3_NAME 200MB 216MB 2>&1` || die "$PARTED_ERROR"
PARTED_ERROR=`parted -s --align optimal $TARGET_DISK mkpart $PART4_NAME 216MB 100% 2>&1` || die "$PARTED_ERROR"
print_done

print_info "Assigning EFI System Partition..."

if [[ "$BOOT_STYLE" == "efi" ]]; then
    sgdisk --typecode=1:C12A7328-F81F-11D2-BA4B-00A0C93EC93B $TARGET_DISK
else
    sfdisk -c $TARGET_DISK 1 EF
fi

print_done

wait_for_partitions $TARGET_DISK

print_info "Formatting partitions..."

MKFS_ERROR=`mkfs.vfat -n $PART1_LABEL ${TARGET_DISK}${PART_SEPARATOR}1 2>&1` || die "$MKFS_ERROR"
mkfs.ext4 $MKFS_ARGS ${TARGET_DISK}${PART_SEPARATOR}2 || die "Format failed!"
mkfs.ext4 $MKFS_ARGS ${TARGET_DISK}${PART_SEPARATOR}3 || die "Format failed!"
mkfs.ext4 $MKFS_ARGS ${TARGET_DISK}${PART_SEPARATOR}4 || die "Format failed!"

LABEL_ERROR=`e2label ${TARGET_DISK}${PART_SEPARATOR}2 $PART2_LABEL 2>&1` || die "$LABEL_ERROR"
LABEL_ERROR=`e2label ${TARGET_DISK}${PART_SEPARATOR}3 $PART3_LABEL 2>&1` || die "$LABEL_ERROR"
LABEL_ERROR=`e2label ${TARGET_DISK}${PART_SEPARATOR}4 $PART4_LABEL 2>&1` || die "$LABEL_ERROR"

print_done

#install grub

GRUB_MOUNTPOINT=/var/volatile/grub
mkdir $GRUB_MOUNTPOINT -p
MOUNT_ERROR=`mount -L $PART1_LABEL $GRUB_MOUNTPOINT 2>&1` || die "$MOUNT_ERROR"

if [[ "$BOOT_STYLE" == "efi" ]]; then
    print_info "Configuring EFI grub2..."
    GRUB_TARGET_DIR=$GRUB_MOUNTPOINT/efi/boot
    mkdir -p $GRUB_TARGET_DIR
    GRUB_TARGET=$(uname -m)
    cp /boot/EFI/BOOT/bootx64.efi $GRUB_TARGET_DIR
    for ENTRY in `$SOURCE_DIR/provision/efimgr -q | grep "LabVIEW RT"| egrep -o '[0-9A-F]{4}' || true`
    do
	    EFIMGR=`$SOURCE_DIR/provision/efimgr -b $ENTRY -B 2>&1` || print_warning "efimgr -b $ENTRY -B failed with: $EFIMGR"
    done
    efibootmgr -c -d ${TARGET_DISK} -p 1 -L 'LabVIEW RT' -l '\efi\boot\bootx64.efi'
else
    print_info "Configuring legacy grub2..."
    GRUB_TARGET_DIR=$GRUB_MOUNTPOINT/boot/grub
    cd $SOURCE_DIR/grub2-legacy
    #grub tools expect /lib64 instead of /lib
    ln -sf /lib /lib64
    # set ${TARGET_DISK}1 boot flag on
    parted -s ${TARGET_DISK} set 1 boot on
    ./grub-install --recheck -d ./grub-core --grub-probe=./grub-probe --grub-setup=./grub-bios-setup --root-directory=$GRUB_MOUNTPOINT $TARGET_DISK
    cd $OLDPWD
fi
print_done

print_info "Installing grub.cfg..."

cp $SOURCE_DIR/safemode_files/grub.cfg $GRUB_TARGET_DIR/grub.cfg
mkdir -p $GRUB_TARGET_DIR/fonts
cp $SOURCE_DIR/safemode_files/fonts/unicode.pf2 $GRUB_TARGET_DIR/fonts/
print_done

print_info "Installing safemode kernel and ramdisk..."
#install safemode kernel and ramdisk
BOOTFS_MOUNTPOINT=/var/volatile/bootfs
mkdir $BOOTFS_MOUNTPOINT -p
BOOTFS_ERROR=`mount -L $PART2_LABEL $BOOTFS_MOUNTPOINT 2>&1` || die "$BOOTFS_ERROR"
mkdir -p $BOOTFS_MOUNTPOINT/.safe

safemode_files=(bzImage ramdisk.gz bootimage.ini bootimage.cfg)
for safemode_file in ${safemode_files[@]}; do
    cp $SOURCE_DIR/safemode_files/$safemode_file $BOOTFS_MOUNTPOINT/.safe
done

print_done

if $use_ramfs; then
    # create boot flags dir and configure initially for safemode boot
    print_info "Installing bootflags.d..."
    mkdir $BOOTFS_MOUNTPOINT/bootflags.d
    echo -n "" >$BOOTFS_MOUNTPOINT/bootflags.d/safemode
    print_done
else
    # write initial bootmode file
    print_info "Installing bootmode file..."
    echo "set BOOT_MODE=safemode" >$BOOTFS_MOUNTPOINT/bootmode
    print_done
fi

#check if target is NI target
NI_TARGET=false
[ is_ni_device ] && NI_TARGET=true

mkdir $BOOTFS_MOUNTPOINT/grub
touch $BOOTFS_MOUNTPOINT/grub/grubenv
touch $BOOTFS_MOUNTPOINT/.safe/SMBIOS_NI_vars
touch $BOOTFS_MOUNTPOINT/.safe/EFI_NI_vars
touch $BOOTFS_MOUNTPOINT/.safe/GRUB_NI_readonly_vars
if [[ "$NI_TARGET" == "true" ]]; then
    #is ni target
    cp $SOURCE_DIR/safemode_files/grubenv $BOOTFS_MOUNTPOINT/grub
    cp $SOURCE_DIR/safemode_files/SMBIOS_NI_vars $BOOTFS_MOUNTPOINT/.safe
    if [[ "$BOOT_STYLE" == "efi" ]]; then
        cp $SOURCE_DIR/safemode_files/EFI_NI_vars $BOOTFS_MOUNTPOINT/.safe
        add_USB_gadget_args_to_grubenv
        override_primaryport_grubenv
    fi
else
    cp $SOURCE_DIR/safemode_files/grubenv_non_ni_target $BOOTFS_MOUNTPOINT/grub/grubenv
fi

set_serial_port

grub-editenv $BOOTFS_MOUNTPOINT/grub/grubenv set "BIOSBootMode=$BOOT_STYLE"
grub-editenv $BOOTFS_MOUNTPOINT/grub/grubenv set "NITarget=$NI_TARGET"

# If target has a TPM chip, we need to enable an alternate boot flow
#  involving initramfs and bootflags dir
if $use_ramfs; then
    grub-editenv $BOOTFS_MOUNTPOINT/grub/grubenv set "enable_initramfs=1"
fi

# Mark aforementioned grub vars read-only
for varname in "BIOSBootMode" "NITarget" "enable_initramfs"; do
    echo "$varname" >> "$BOOTFS_MOUNTPOINT/.safe/GRUB_NI_readonly_vars"
done

# save rootfs UUID for grub to reference
if [[ "$BOOT_STYLE" == "efi" ]]; then
    ROOTUUID=`lsblk ${TARGET_DISK}${PART_SEPARATOR}4 -n -o PARTUUID`
else
    # On msdos partitions, the NT disk signature is accepted as a valid
    # PARTUUID value. The PARTUUID has the format SSSSSSSS-PP, where
    # the first field is the "NT disk signature" and the second field is the
    # partition number.  Both fields use hex representation.

    # Read "NT disk signature" from MBR offset 0x1B8 (440d) and
    # append rootfs partition number.
    ROOTUUID=`hexdump -s 440 -n 4 -e '1 4 "%08x" "\n"' ${TARGET_DISK}`-04
fi
echo set rootuuid=$ROOTUUID >> $GRUB_MOUNTPOINT/grubvar_readonly

# set proper permissions on and backup firmware variable files
chown 0:500 $BOOTFS_MOUNTPOINT/grub/grubenv
chmod ug=rw,o=r $BOOTFS_MOUNTPOINT/grub/grubenv
cp -p $BOOTFS_MOUNTPOINT/grub/grubenv $BOOTFS_MOUNTPOINT/grub/grubenv.bak
chmod a=r $BOOTFS_MOUNTPOINT/.safe/SMBIOS_NI_vars
chmod a=r $BOOTFS_MOUNTPOINT/.safe/EFI_NI_vars
chmod a=r $BOOTFS_MOUNTPOINT/.safe/GRUB_NI_readonly_vars

# Additional grubenv configuration, _NOT_ mirrored in grubenv.bak

# If an initial value for console out was specified, write it to grubenv
if [ -n "$grubenv_consoleoutenable" ]; then
    grub-editenv $BOOTFS_MOUNTPOINT/grub/grubenv set "consoleoutenable=$grubenv_consoleoutenable"
fi

# If an initial value for bootdelay was specified, write to to grubenv
if [ -n "$grubenv_bootdelay" ]; then
    grub-editenv $BOOTFS_MOUNTPOINT/grub/grubenv set "bootdelay=$grubenv_bootdelay"
fi

# Set the bootdelay to show the boot menu on PXI controllers
#
# The reasoning behind this is that, for NI Linux RT support, Controller
# Software (the BIOS team) wants to keep the business logic out of
# BIOS as much as possible, and make the BIOS agnostic of the actual
# OS it is booting as much as possible (one exception being setting
# HT based on the EFI variable since this can only, practically, be
# handled in BIOS).

if [ "`get_target_class`" == "PXI" ]; then
    grubenv_bootdelay=${grubenv_bootdelay:-3}
fi

# mount config partition and set proper ownership/permissions
CONFIG_MOUNTPOINT=/var/volatile/configfs
mkdir -p $CONFIG_MOUNTPOINT
mount -L $PART3_LABEL $CONFIG_MOUNTPOINT
chown 500:500 $CONFIG_MOUNTPOINT
chmod ug=rwx,o=rx $CONFIG_MOUNTPOINT

echo $LOG_LEVEL > /proc/sys/kernel/printk

print_info "Unmounting partitions..."
sync
umount_partitions
print_done

print_info "Sanity check TARGET_DISK=$TARGET_DISK..."

# correct partition table type
parted -s --list "$TARGET_DISK" | grep -q "^Partition Table: $PART_STYLE" || die "Wrong partition style reported"

attrib_list="NAME KNAME PARTUUID UUID LABEL"
if [[ "$PART_STYLE" == "gpt" ]]; then
	attrib_list="$attrib_list PARTLABEL"
fi

# unique attributes
for attrib_name in $attrib_list; do
    sanity_list="`lsblk -nro "$attrib_name" "$TARGET_DISK"`"
    sanity_list_len="`echo "$sanity_list" | wc -l`"
    sanity_list_uniq_len="`echo "$sanity_list" | uniq | wc -l`"
    [ "$sanity_list_len" -eq 5 ] || die "There should be 4 $attrib_name's (+1 blank line) on TARGET_DISK=$TARGET_DISK; found $sanity_list_len"
    [ "$sanity_list_len" -eq "$sanity_list_uniq_len" ] || die "$attrib_name's not unique on TARGET_DISK=$TARGET_DISK; $sanity_list_len != $sanity_list_uniq_len"
done

# can search by file system label
for fs_label in "$PART1_LABEL" "$PART2_LABEL" "$PART3_LABEL" "$PART4_LABEL"; do
    fs_node_name="`lsblk -nro LABEL,NAME "$TARGET_DISK" | grep "^$fs_label " | cut -d" " -f2`"
    [ "`echo "$fs_node_name" | wc -l`" -eq 1 ] || die "Invalid number of devnodes found"
    [ -e "/dev/$fs_node_name" ] || die "No devnode for LABEL $fs_label"
done

# can search by partition label, on gpt only
if [ "$PART_STYLE" == "gpt" ]; then
    for part_label in "$PART1_NAME" "$PART2_NAME" "$PART3_NAME" "$PART4_NAME"; do
        part_node_name="`lsblk -nro PARTLABEL,NAME "$TARGET_DISK" | grep "^$part_label " | cut -d" " -f2`"
        [ "`echo "$part_node_name" | wc -l`" -eq 1 ] || die "Invalid number of devnodes found"
        [ -e "/dev/$part_node_name" ] || die "No devnode for PARTLABEL $part_label"
    done
fi

# just in case meta-data is updated
sync

print_done

print_info "Re-enabling automount..."
enable_automount
print_done

trap - ERR
exec 1>&3
exec 2>&4


cleanup

green='\e[0;32m'
echo -e ${green}"PROVISIONING SUCCESSFUL!"${NC} 1>&3 2>&4

exit 0