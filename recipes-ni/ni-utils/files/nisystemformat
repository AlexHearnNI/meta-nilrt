#!/bin/bash
#
# Copyright (c) 2013 National Instruments
#
# Format rootfs and the config volumes and delete the runmode kernel
#

# include common utilities
if [ -e /etc/init.d/mountutils ]; then
	source /etc/init.d/mountutils
fi

# Bail out on first error
set -E -o errexit

arch=`uname -m`

NETCFG_MODE=bypass

NETCFG_TMP=/tmp/netconfig.$$
declare -r BASENAME=${0##*/}

NINETCFGUTIL=/usr/local/natinst/bin/ninetcfgutil

# List of returnable errors
declare -Ar EXITCODES=(
	[UNSPECIFIED]=1		# No reason specified
	[UNKNOWN_ERROR]=2	# Unexpected exit code encountered
	[INVALID_ARGUMENT]=3	# An invalid combination of arguments was specified
	[INVALID_FSTYPE]=4	# An invalid fstype was specified
)

# $1: exit code (key from EXITCODES)
# ${@:2}: text
die()
{
	echo -e "*** Error: $0:${BASH_LINENO[1]}: ${@:2}" >&2
	exit ${EXITCODES[$1]}
}

die_with_usage()
{
	echo -e "*** Error: ${@:2}" >&2
	usage
	exit ${EXITCODES[$1]}
}

# $1: source path
# $2: line no
# $3: function name
# $4: exit code
handle_err()
{
	echo "*** Error: $1:$2 (fn=$3): Unexpected status code $4" >&2
	exit ${EXITCODES[UNKNOWN_ERROR]}
}

services_stop () {
	/etc/init.d/sshd stop || true
}

services_start () {
	/etc/init.d/sshd start || true
}

install_default_err_handler()
{
	trap 'handle_err ${BASH_SOURCE} ${LINENO} ${FUNCNAME:-unknown} $?' ERR
}

supported_fstypes()
{
	hash /usr/sbin/ubiformat 2>/dev/null && [ "$arch" = "armv7l" ] && echo -n "ubifs," || true
	hash /sbin/mkfs.ext4 2>/dev/null && [ "$arch" = "x86_64" ] && echo -n "ext4," || true
}

# Restore system after rootfs format
# $1: exit code
# $2: line number of trap (if failing)
format_rootfs_cleanup()
{
	/etc/init.d/mountuserfs start
	/etc/init.d/mountcompatibility start

	# Move the restore files back to the rootfs
	if [ -e /tmp/restore ]; then
		mkdir -p /mnt/userfs/.restore
		mv /tmp/restore/* /mnt/userfs/.restore
		rmdir /tmp/restore
	fi

	if (( $1 != 0 )); then
		die UNKNOWN_ERROR "rootfs format failed, line $2, status code $1"
	fi
}

# Format the rootfs volume
# $1: filesystem to use (currently "ubifs" or "ext4")
format_rootfs()
{
	trap 'format_rootfs_cleanup $? $LINENO' ERR

	# Backup the restore files to the tmp dir
	if [ -e /mnt/userfs/.restore ]; then
		mkdir -p /tmp/restore
		cp -R /mnt/userfs/.restore/* /tmp/restore/
	fi

	# unmount rootfs
	/etc/init.d/mountcompatibility stop
	/etc/init.d/mountuserfs stop

	# fstype is validated before calling format_rootfs
	case "$1" in
	  ubifs)
		local partition_label="root"
		local volume_number="0"
		local volume_label="rootfs"
		format_ubi_volume "$partition_label" "$volume_number" "$volume_label"
		;;
	  ext4)
		local volume_label="nirootfs"
		mkfs.ext4 -L $volume_label $(findfs LABEL=$volume_label)
		;;
	esac

	install_default_err_handler
	format_rootfs_cleanup 0
}

# Remove runmode kernel
remove_kernel()
{
	# Zynq case
	rm -f /boot/linux_runmode.itb

	# x64 case
	rm -f /boot/runmode/*
}

# Restore system after config format
# $1: exit code
# $2: line number of trap (if failing)
format_config_cleanup()
{
	/etc/init.d/mountconfig start
	/etc/init.d/populateconfig start
	/etc/init.d/mountuserfs start
	/etc/init.d/mountcompatibility start

	if (( $1 != 0 )); then
		die UNKNOWN_ERROR "configfs format failed, line $2, status code $1"
	fi
}

# Format the config volume
# $1: filesystem to use (currently "ubifs" or "ext4")
format_config()
{
	local mount_point="/etc/natinst/share"

	trap 'format_config_cleanup $? $LINENO' ERR

	services_stop

	# in case services_stop didn't work, or others are using $mount_point
	if fuser -s -m "$mount_point"; then
		fuser -k -m "$mount_point" || :
		sleep 10
	fi

	# unmount config
	/etc/init.d/mountcompatibility stop
	/etc/init.d/mountuserfs stop
	/etc/init.d/populateconfig stop
	/etc/init.d/mountconfig stop

	# fstype is validated before calling format_config
	case "$1" in
	  ubifs)
		local partition_label="boot-config"
		local volume_number="3"
		local volume_label="config"
		format_ubi_volume "$partition_label" "$volume_number" "$volume_label"
		;;
	  ext4)
		local volume_label="niconfig"
		mkfs.ext4 -L $volume_label $(findfs LABEL=$volume_label)
		;;
	esac

	install_default_err_handler
	format_config_cleanup 0
}

# Find the filesystem type of the root partition (or volume)
print_root_fstype()
{
	if [ "$OSMODE" != runmode ]; then
		grep " /mnt/userfs " /proc/mounts | awk '{print $3}'
	else
		# regarding skipping rootfs, see "What is rootfs?" at
		# https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt
		grep " / " /proc/mounts | awk '{if ($3 != "rootfs") print $3}'
	fi
}

# Find the filesystem type of the config partition (or volume)
print_config_fstype()
{
	grep " /etc/natinst/share " /proc/mounts | awk '{print $3}'
}

usage()
{
	if [ "$OSMODE" != runmode ]; then
		cat >&2 <<-EOF
		Usage: $BASENAME [-f -t <type> [-c][-r][-n <mode>]|-s [-c]|-l]

		-f	Format the volume
		-h	Print this help
		-s	List current filesystem type
		-l	List possible filesystem types

		-t	Filesystem type
		-c	Format the config volume (otherwise rootfs + kernel)
		-r	Relaunch system services after format
		-n	Preserve network config according to <mode>:
		        all		Preserve all settings
		        primary		Preserve primary, reset secondary
		        none		Reset all settings
		        bypass		No configuration handling (default)

		Examples:

		$BASENAME -f -t <type>	- format the rootfs as <type> fs
		$BASENAME -s -c		- print the filesystem type of the config volume
		$BASENAME -l		- list possible filesystem types (',' separated)

		EOF
	else
		cat >&2 <<-EOF
		Usage: $BASENAME [-s [-c]|-l]

		-h	Print this help
		-s	List current filesystem type
		-l	List supported filesystem types
		-c	Config volume (otherwise rootfs + kernel)

		Examples:

		$BASENAME -s		print the filesystem type of the rootfs volume
		$BASENAME -s -c		print the filesystem type of the config volume

		EOF
	fi
}

netconfig_pre()
{
	[[ $NETCFG_MODE == bypass || $NETCFG_MODE == none ]] && return 0
	rm -rf $NETCFG_TMP
	mkdir -p $NETCFG_TMP
	OPTS=()
	case "$NETCFG_MODE" in
		all) OPTS+=(-g secondary) ;&
		primary) OPTS+=(-g primary) ;;
	esac
	$NINETCFGUTIL save -d $NETCFG_TMP ${OPTS[@]}
}

netconfig_post()
{
	case "$NETCFG_MODE" in
		bypass)
			return 0 ;;
		all|primary)
			$NINETCFGUTIL restore -d $NETCFG_TMP
			rm -rf $NETCFG_TMP
			;;
		none)
			rm -rf $NETCFG_TMP
			mkdir -p $NETCFG_TMP
			$NINETCFGUTIL erase -d $NETCFG_TMP -g primary -g secondary
			rm -rf $NETCFG_TMP
			mkdir -p $NETCFG_TMP
			$NINETCFGUTIL pulldefault -d $NETCFG_TMP -g primary -g secondary
			rm -rf $NETCFG_TMP
			;;
	esac
}

install_default_err_handler

# Are we running in safemode, restore mode, or runmode?
if [ -f /etc/natinst/safemode ]; then
	OSMODE=safemode
elif [ -f /etc/natinst/restoremode ]; then
	OSMODE=restore
else
	# in runmode the rootfs is in use, restricting available options
	OSMODE=runmode
fi

# Script invoked with no command-line args?
if [ $# -eq "0" ]
then
	die_with_usage INVALID_ARGUMENT "No command-line arguments specified."
fi

while getopts "fhsln:t:cr" Option
do
	case $Option in
		f)	MODE=format;;
		h)	usage; exit 0 ;;
		s)	MODE=status;;
		l)	MODE=list;;
		t)	TYPE=$OPTARG;;
		c)	VOL=config;;
		r)	RELAUNCH=yes;;
		n)	NETCFG_MODE="$OPTARG";;
		*)	usage;;
	esac
done

if [ "$MODE" = format -a "$OSMODE" = runmode ]; then
	die_with_usage INVALID_ARGUMENT "Formatting is not available in runmode."
fi

if [ "$RELAUNCH" = yes ]; then
	if [ "$MODE" != format -o "$VOL" != config ]; then
		die_with_usage INVALID_ARGUMENT \
			"relaunch (-r) can only be used when formatting config partition (-f -c)"
	fi
	if [ "$OSMODE" = restore ]; then
		die_with_usage INVALID_ARGUMENT \
			"relaunch (-r) cannot be used in restore mode"
	fi
fi

if [ -n "$TYPE" ]; then
	if [ "$MODE" = status -o "$MODE" = list ]; then
		die_with_usage INVALID_ARGUMENT \
			"fstype option (-t) cannot be used with status -s or -l"
	fi
fi

if [ "$MODE" = list -a -n "$VOL" ]; then
	die_with_usage INVALID_ARGUMENT \
		"Volume name (-v) cannot be specified when listing fs types (-l)"
fi

if [ "$MODE" != format -a "$NETCFG_MODE" != "bypass" ]; then
	die_with_usage INVALID_ARGUMENT \
		"Network settings (-n) can only be specified when formatting (-f)"
fi

case "$NETCFG_MODE" in
	all|primary|none|bypass) ;;
	*)
		die_with_usage INVALID_ARGUMENT \
			"Unknown network config setting $NETCFG_MODE"
		;;
esac

if [ "$MODE" = format ]; then
	if [ -z "$TYPE" ]; then
		die_with_usage INVALID_FSTYPE "No filesystem type was specified"
	fi

	[[ $(supported_fstypes) =~ (^|,)$TYPE(,) ]] || die_with_usage INVALID_FSTYPE "Invalid fstype '$TYPE'"
fi

case "$MODE" in
	format)
		netconfig_pre
		if [ "$VOL" = config ]; then
			format_config $TYPE
		else
			remove_kernel
			format_rootfs $TYPE
		fi
		netconfig_post
		if [ "$RELAUNCH" = yes ]; then
			services_start
		fi
	;;
	status)
		if [ "$VOL" = config ]; then
			print_config_fstype
		else
			print_root_fstype
		fi
	;;
	list)
		echo -n $(supported_fstypes)
	;;
esac

exit 0
