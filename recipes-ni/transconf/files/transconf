#!/bin/bash
set -euo pipefail

# close stdin to avoid unexpected behavior
exec 0<&-

# set sensible umask for tar operations
umask 0022

# disable core dumps since we may be dealing with sensitive data
ulimit -c 0

# overrideable config by options
export TRANSCONF_DEBUG=0
export TRANSCONF_CONFIG_DIR="/etc/transconf"
export TRANSCONF_SYSROOT="/"

# working dirs generated by init_work_dir()
export TRANSCONF_WORK_DIR=""
export TRANSCONF_EMPTY_DIR=""
export TRANSCONF_IMAGE_DIR=""

# Latest image version understood by transconf, written by save(), checked on restore()
export TRANSCONF_MAX_IMAGE_VERSION="1"

function print_usage_and_die () {
    local message="$1"
    cat >&2 <<ENDHELP

ERROR: $message

Usage: $0 [-c config.dir] [-s sysroot.dir] command

 options:
  -d: Enable debug prints to stderr
  -c config.dir: Config directory, defaults to /etc/transconf
  -s sysroot.dir: Sysroot to save/restore, defaults to /

 commands:
  lshooks                 Show installed hooks which donate and restore
                          configuration
  save archive.tar.gz     Invokes all hooks to save configuration into
                          archive.zip
  restore archive.tar.gz  Invokes all hooks to restore configuration from
                          archive.zip

ENDHELP

    false
}

function status() {
    if [ "$TRANSCONF_DEBUG" == "1" ]; then
        echo "DEBUG: $*" 1>&2
    fi
}

function warning() {
    echo "WARNING: $*" 1>&2
}

function error() {
    echo "ERROR: $*" 1>&2
    false
}

export -f status
export -f warning
export -f error

function cleanup() {
    local exit_code="$?"

    set +e

    status "cleanup() called"

    if [ -e "$TRANSCONF_WORK_DIR"  ]; then
        rm -Rf "$TRANSCONF_WORK_DIR"
    fi
    status "Deleted TRANSCONF_WORK_DIR=$TRANSCONF_WORK_DIR"

    exit "$exit_code"
}

trap cleanup EXIT

function init_work_dir() {
    status "init_work_dir() called"

    TRANSCONF_WORK_DIR=$(mktemp -d "/tmp/transconf-XXXXXXX")
    chmod 0700 "$TRANSCONF_WORK_DIR"
    status "Created TRANSCONF_WORK_DIR=$TRANSCONF_WORK_DIR"

    TRANSCONF_EMPTY_DIR="$TRANSCONF_WORK_DIR/empty"
    mkdir "$TRANSCONF_EMPTY_DIR"
    chmod 0500 "$TRANSCONF_EMPTY_DIR"
    status "Created TRANSCONF_EMPTY_DIR=$TRANSCONF_EMPTY_DIR"

    TRANSCONF_IMAGE_DIR="$TRANSCONF_WORK_DIR/transconf-image"
    mkdir "$TRANSCONF_IMAGE_DIR"
    chmod 0700 "$TRANSCONF_IMAGE_DIR"
    status "Created TRANSCONF_IMAGE_DIR=$TRANSCONF_IMAGE_DIR"
}

function check_archive() {
    local archive_path="$1"
    [ -n "$archive_path" ] || print_usage_and_die "Must specify path to tar.gz archive"
}

function run_tar() {
    local common_tar_opts="--no-same-owner --no-same-permissions --no-acls --no-xattr --owner=0 --group=0 --mode=0777"
    status "Running: tar $common_tar_opts $*"
    tar $common_tar_opts $*
}

function run_hooks() {
    status "Running: run-parts $* '$TRANSCONF_CONFIG_DIR/hooks'"
    cd "$TRANSCONF_EMPTY_DIR"
    run-parts $* "$TRANSCONF_CONFIG_DIR/hooks"
    cd - >/dev/null
}

function lshooks() {
    status "lshooks() called"
    run_hooks --test
}

function save() {
    status "save() called"

    local archive_path="$1"
    check_archive "$archive_path"

    init_work_dir

    run_hooks -a "save"
    echo "$TRANSCONF_MAX_IMAGE_VERSION" >"$TRANSCONF_IMAGE_DIR/version"

    status "Truncate archive_path=$archive_path and set user-only rw permissions"
    echo -n "" > "$archive_path"
    chmod 0600 "$archive_path"

    run_tar --create --gzip --file="$archive_path" --directory="$TRANSCONF_WORK_DIR" "./transconf-image"

    status "sync file systems"
    sync
}

function restore() {
    status "restore() called"

    local archive_path="$1"
    check_archive "$archive_path"

    init_work_dir

    run_tar --extract --file="$archive_path" --directory="$TRANSCONF_WORK_DIR" "./transconf-image"

    local image_version=$(cat "$TRANSCONF_IMAGE_DIR/version")
    [ "$TRANSCONF_MAX_IMAGE_VERSION" -ge "$image_version" ] || error "Incompatible image version, max supported version is '$TRANSCONF_MAX_IMAGE_VERSION', image version is '$image_version'"

    run_hooks -a "restore"

    status "sync file systems"
    sync
}

# parse options
while getopts "dc:s:" opt; do
    case "$opt" in
    d) TRANSCONF_DEBUG=1 ;;
    c) TRANSCONF_CONFIG_DIR="$OPTARG" ;;
    s) TRANSCONF_SYSROOT="$OPTARG" ;;
    \?) print_usage_and_die "Invalid arg" ;;
    esac
done
shift $(($OPTIND - 1))

# need to ensure absolute paths since we cd in save() and restore()
[ "${TRANSCONF_CONFIG_DIR:0:1}" == "/" ] || print_usage_and_die "Config path must be absolute"
[ "${TRANSCONF_SYSROOT:0:1}" == "/" ] || print_usage_and_die "Sysroot path must be absolute"

# parse command and positional args, and run
command_arg="${1:-}"
archive_path_arg="${2:-}"
case "$command_arg" in
    "lshooks") lshooks ;;
    "save") save "$archive_path_arg" ;;
    "restore") restore "$archive_path_arg" ;;
    *) print_usage_and_die "Invalid command '$command_arg'" ;;
esac
